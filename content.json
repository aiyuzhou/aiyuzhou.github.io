{"meta":{"title":"Annie","subtitle":"ah~ha,时间","description":"","author":"Annie Chou","url":"https://aiyuzhou.github.io"},"pages":[{"title":"tags","date":"2016-12-15T04:19:32.000Z","updated":"2016-12-15T05:26:29.000Z","comments":true,"path":"tags/index.html","permalink":"https://aiyuzhou.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"静下心来，思考","slug":"静下心来，思考","date":"2016-12-18T09:08:04.000Z","updated":"2016-12-18T09:11:44.000Z","comments":true,"path":"2016/12/18/静下心来，思考/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/18/静下心来，思考/","excerpt":"","text":"","categories":[],"tags":[{"name":"【life,thinking】","slug":"【life-thinking】","permalink":"https://aiyuzhou.github.io/tags/【life-thinking】/"}]},{"title":"canvas实现小球的弹性碰撞","slug":"bouncing1","date":"2016-12-16T10:02:37.000Z","updated":"2016-12-18T09:31:41.000Z","comments":true,"path":"2016/12/16/bouncing1/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/16/bouncing1/","excerpt":"","text":"写在最前面首先，代码源于supperjet源码: 小球碰撞运动效果图如下：写之前，想一个问题，如果我要写一个box内弹性碰撞的小球的动画，我应该从哪里入手。 先从对象开始考虑，我需要定义ball和box两个对象，ball需要有大小，颜色，所在位置这些属性，box只需要有长宽属性，而在动画中canvas就是box。 考虑碰撞规则 若碰撞到box的上边，则碰撞条件是：ball的中心点坐标 y 小于其自身半径 radius，解决方法是：将ball的中心点坐标 y 置为ball.radius并且ball的垂直运动方向反向 若碰撞到box的下边，则碰撞条件是：ball的中心点坐标 y 与其自身半径 radius之和大于box的height，解决方法是：将ball的中心点坐标 y 置为box.height - ball.radius并且ball的垂直运动方向反向 若碰撞到box的左边，则碰撞条件是：ball的中心点坐标 x 小于其自身半径 radius，解决方法是：将ball的中心点坐标 x 置为ball.radius并且ball的水平运动方向反向 若碰撞到box的右边，则碰撞条件是：ball的中心点坐标 x 与其自身半径 radius之和大于box的width，解决方法是：将ball的中心点坐标 x 置为box.width - ball.radius并且ball的水平运动方向反向 ball的实现是每次运动都重新渲染画布，所以，ball还需要一个draw的方法来完成自身的渲染 代码实现ball对象function Ball(radius,color){ if(radius === undefined) {radius = 40;} if(color === undefined){color = &apos;#00ff00&apos;;} this.x = 0; //中心点坐标x,y this.y = 0; this.vx = 0; //小球的水平及垂直运动方向 this.vy = 0; this.radius = radius; this.color = color; } box对象（即canvas）&lt;canvas id=&apos;canvas&apos; width=&quot;400&quot; height=&quot;300&quot; style=&quot;background:#000&quot;&gt;&lt;/canvas&gt; 碰撞规则ball.x = ball.x + ball.vx; //小球运动 ball.y = ball.y + ball.vy; //碰撞规则 if(ball.y &lt; ball.radius){ ball.y = ball.radius; ball.vy = ball.vy*(-1); } if(ball.y + ball.radius &gt; canvas.height){ ball.y = canvas.height - ball.radius; ball.vy = ball.vy*(-1); } if(ball.x &lt; ball.radius){ ball.x = ball.radius; ball.vx = ball.vx*(-1); } if(ball.x + ball.radius &gt; canvas.width){ ball.x = canvas.width - ball.radius; ball.vx = ball.vx*(-1); } 小球渲染Ball.prototype.draw = function(context){ context.save(); context.translate(this.x,this.y); context.fillStyle = this.color; context.strokeStyle = this.color; context.beginPath(); context.arc(0,0,this.radius,0,Math.PI*2,false); context.closePath(); context.fill(); context.stroke(); context.restore(); }","categories":[],"tags":[{"name":"animation","slug":"animation","permalink":"https://aiyuzhou.github.io/tags/animation/"},{"name":"canvas","slug":"canvas","permalink":"https://aiyuzhou.github.io/tags/canvas/"},{"name":"bouncing","slug":"bouncing","permalink":"https://aiyuzhou.github.io/tags/bouncing/"}]},{"title":"H5-Animation-canvas百分比加载","slug":"H5-Animation-canvas百分比加载","date":"2016-12-16T04:02:41.000Z","updated":"2016-12-16T08:17:59.000Z","comments":true,"path":"2016/12/16/H5-Animation-canvas百分比加载/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/16/H5-Animation-canvas百分比加载/","excerpt":"","text":"首先，代码源于supperjet，我是边看代码边学习记笔记。源码: canvas百分比加载 效果图是这样的: 代码解析drawFrame(function drawFrame(){ window.requestAnimationFrame(drawFrame, canvas); context.clearRect(0, 0, canvas.width, canvas.height); whiteCircle(); text(speed); blueCircle(speed); if(speed &gt; 100) speed = 0; speed += 0.1; }()); window.requestAnimationFrame(drawFrame, canvas);相当于是个递归吧，相当于是canvas每次调用一次drawFrame来重新渲染画布。 clearRect来清除画布内容，其实这里就很清楚了，canvas的动画效果只是视觉上的动画，并非真的一点一点在变，大概意思就是：我要把一段直线从1cm变到2cm，我是先画了1cm的线段，在把这个画布清除，然后在画2cm的线段，而不是视觉上的先画1cm，然后在1cm的基础上再画1cm。 代码解析whiteCirclefunction whiteCircle(){ context.save(); context.beginPath(); context.strokeStyle = &quot;white&quot;; context.arc(centerX, centerY, 100 , 0, Math.PI*2, false); context.stroke(); context.closePath(); context.restore(); console.log(&quot;whiteCircle&quot;); } whiteCircle()用来画白色的底线，底线一直都是完整圆，所以都是0，2π 代码解析textfunction text(n){ context.save(); context.strokeStyle = &quot;#49f&quot;; context.font = &quot;40px Arial&quot;; context.strokeText(n.toFixed(0)+&quot;%&quot;, centerX-25, centerY+10); context.stroke(); context.restore(); } text(speed)用来变化百分比这个n.toFixed(0)四舍五入保留一位，所以是从0~100 代码解析blueCirclefunction blueCircle(n){ context.save(); context.beginPath(); context.strokeStyle = &quot;#49f&quot;; context.lineWidth = 5; context.arc(centerX, centerY, 100 , -Math.PI/2, -Math.PI/2 +n*rad, false); context.stroke(); context.closePath(); context.restore(); } blueCircle(speed)蓝线表示进度条，每次都从-1/2π开始画到-1/2π + speed*rad(rad = 2π/100) window.requestAnimationFrame(drawFrame, canvas)是浏览器来调用的，自然在流畅性上比setInterval和setTimeout好，并且节省资源，如果用setInterval来实现 var timer = setInterval(function () { context.clearRect(0, 0, canvas.width, canvas.height); whiteCircle(); text(speed); blueCircle(speed); if(speed &gt; 100) { speed = 0; //clearInterval(timer);//如果只执行一次，在这里清除句柄就OK } speed += 0.1; },50); 同样window.requestAnimationFrame也会返回唯一表示requestID，可用window.cancelAnimationFrame()来取消回调函数.","categories":[],"tags":[{"name":"H5","slug":"H5","permalink":"https://aiyuzhou.github.io/tags/H5/"},{"name":"animation","slug":"animation","permalink":"https://aiyuzhou.github.io/tags/animation/"},{"name":"canvas","slug":"canvas","permalink":"https://aiyuzhou.github.io/tags/canvas/"}]},{"title":"写在最前面","slug":"写在最前面","date":"2016-12-15T08:29:14.000Z","updated":"2016-12-16T08:25:34.000Z","comments":true,"path":"2016/12/15/写在最前面/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/15/写在最前面/","excerpt":"","text":"终于，我开始写博客了 更新：为什么要写博客，我写博客的重要目的是记笔记，因为平时所谓的看懂了听懂了搞明白了，都是粗略的懂了，但是讲的时候很难讲清楚，我自己本来就有些不善表达，更准确的说是不善于组织语言，所以写博客记笔记的过程中其实是一个很好的思考过程，你要把问题说明白，这对自己来说我觉得是很大的提升，所以，保持一个书写的习惯是非常好的，我以后会把之前写的笔记慢慢整理上来。 写在最前面 除去前两篇的测试文章，这大概算是我非常正式的写在自己的博客里的第一篇文章了，为什么说是大概呢！！！原因是： 我很早很早之前就想开始写博客了，至于多早，应该是我刚刚入门前端的时候吧，那个时候每次在网上搜寻学习过程中遇到的一些问题时，见到不少形式的博客，有写在CSDN的，有博客园的，有简书的，有github的，于是啊，我就萌生了自己写一个博客系统的想法，现在想想真是可笑啊哈哈哈哈哈哈。。。那时用的是javaweb，最后的结果呢，就是写了些静态的漂亮的页面，简单的交互：有阅读全文跳转到整章阅读，在article页面，阅读全文则全部文章的wrap div设置为display：none,单个文章的wrap div设置为display：block，然后js将内容换位点击那篇文章的内容。恩，然后我意识到自己一个人写一个系统不现实，我开始动手写的时候就是脑子一热就开始写了，完全没有考虑到一个博客系统项目架构，模块，数据库存储，到最后部署上线不是我一个刚刚入门的小菜鸟能搞定的，终于认清楚以后，就在这里停下来。 我开始在印象笔记里零零散散的记一些知识，也在电脑创建过文件夹用markdown来记笔记，太零散了，整理的时候真希望有个标签一点就把我要的文章找出来。 所以，在这么长的时间过去之后，我快毕业了，我终于决定搭建我的博客，对，就是今天，斟酌一番后，决定用最简易的github Pages和hexo来搭建博客（之前非常蠢得准备自己写一个博客系统的时候，还没有开始用github，捂脸逃），选了个自己喜欢的主题，就这样我的真正的博客开通了。 记录目前生活状态我是Annie Chou，是一名程序媛，现在就读于西安电子科技大学，于明年7月毕业。目前在北京一家智能硬件创业公司实习，也打算继续留在这里工作。 希望自己可以在前端的路上摸爬打滚越滚越远！","categories":[],"tags":[]},{"title":"linux命令 chmod 755的含义","slug":"linux命令_chmod_755的含义","date":"2016-12-15T04:38:32.000Z","updated":"2016-12-15T05:27:41.000Z","comments":true,"path":"2016/12/15/linux命令_chmod_755的含义/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/15/linux命令_chmod_755的含义/","excerpt":"","text":"linux命令 chmod 755的含义chmod是Linux下设置文件权限的命令，后面的数字表示不同用户或用户组的权限。一般是三个数字：第一个数字表示文件所有者的权限第二个数字表示与文件所有者同属一个用户组的其他用户的权限第三个数字表示其它用户组的权限。 权限分为三种：读（r=4），写（w=2），执行（x=1） 。 综合起来还有可读可执行（rx=5=4+1）、可读可写（rw=6=4+2）、可读可写可执行(rwx=7=4+2+1)。 所以，chmod 755 设置用户的权限为： 1.文件所有者可读可写可执行 –72.与文件所有者同属一个用户组的其他用户可读可执行 –53.其它用户组可读可执行 –5","categories":[],"tags":[{"name":"chmod","slug":"chmod","permalink":"https://aiyuzhou.github.io/tags/chmod/"}]},{"title":"angular学习笔记（一）—— 创建自定义指令","slug":"angular学习笔记（一）——_创建自定义指令","date":"2016-12-15T04:19:32.000Z","updated":"2016-12-15T05:19:06.000Z","comments":true,"path":"2016/12/15/angular学习笔记（一）——_创建自定义指令/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/15/angular学习笔记（一）——_创建自定义指令/","excerpt":"","text":"angular学习笔记（一）—— 创建自定义指令使用驼峰法来命名一个指令， runoobDirective, 但在使用它时需要以 - 分割, runoob-directive:实例： &lt;runoob-directive&gt;&lt;/runoob-directive&gt; &lt;script&gt; var app = angular.module(&quot;myApp&quot;, []); app.directive(&quot;runoobDirective&quot;, function() { return { template : &quot;&lt;h1&gt;自定义指令!&lt;/h1&gt;&quot; }; }); &lt;/script&gt; 元素名 &lt;runoob-directive&gt;&lt;/runoob-directive&gt; 属性 &lt;div runoob-directive&gt;&lt;/div&gt; 类名 &lt;div class=&quot;runoob-directive&quot;&gt;&lt;/div&gt; 注释 &lt;!-- directive: runoob-directive --&gt; 限制使用你可以限制你的指令只能通过特定的方式来调用。 实例 通过添加 restrict 属性,并设置只值为 “A”, 来设置指令只能通过属性的方式来调用: var app = angular.module(&quot;myApp&quot;, []); app.directive(&quot;runoobDirective&quot;, function() { return { restrict : &quot;A&quot;, template : &quot;&lt;h1&gt;自定义指令!&lt;/h1&gt;&quot; }; }); restrict 值可以是以下几种: E 作为元素名使用 A 作为属性使用 C 作为类名使用 M 作为注释使用 restrict 默认值为 EA, 即可以通过元素名和属性名来调用指令。","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"https://aiyuzhou.github.io/tags/angular/"}]}]}