{"meta":{"title":"Annie","subtitle":"ah~ha,时间","description":"","author":"Annie Chou","url":"https://aiyuzhou.github.io"},"pages":[{"title":"tags","date":"2016-12-15T04:19:32.000Z","updated":"2016-12-15T05:26:29.000Z","comments":true,"path":"tags/index.html","permalink":"https://aiyuzhou.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"xcode调试ionic项目","date":"2017-02-24T10:53:13.000Z","updated":"2017-02-28T07:40:18.000Z","comments":true,"path":"2017/02/24/xcode调试ionic项目/","link":"","permalink":"https://aiyuzhou.github.io/2017/02/24/xcode调试ionic项目/","excerpt":"","text":"ionic build ios出现Error：munger.add_config_changes is not a function原因可能是版本不匹配导致更新cordova：npm update -g cordova更新后：rm -r platforms &amp;&amp; rm -r plugins重新添加平台：ionic platform add ios重新build：inoic build ios发现build成功在使用onesignal-cordova-plugin时出现window.plugins.onsignal.init not a function 当使用node-sass时出现libsass bindings not found时 先根据提示reinstall node-sass npm uninstall node-sass npm install node-sass 若是仍然有错误，重装所有node-moudles rm -rf node-moudles npm install 若是仍然有错误，重新build node-sass npm rebuild node-sass 若是仍然有错误，则可能是gulp-sass的版本过低 npm uninstall --save-dev gulp-sass npm install --save-dev gulp-sass@2 gulp-sass是使用gulp构建项目时把sass编译成css的一个插件，当你使用node4.x及以上版本时，则会需求更高版本的gulp-sass","categories":[],"tags":[]},{"title":"","slug":"JavaScript事件","date":"2017-02-22T05:42:43.000Z","updated":"2017-02-22T09:00:50.000Z","comments":true,"path":"2017/02/22/JavaScript事件/","link":"","permalink":"https://aiyuzhou.github.io/2017/02/22/JavaScript事件/","excerpt":"","text":"IE事件处理程序 IE实现了与DOM2级事件处理程序类似的两个方法：attachEvent（）和detachEvent（）。 这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。 通过attachEvent（）添加的事件处理程序都会被添加到冒泡阶段。 而且attachEvent（）的第一个参数是”onclick”,”onload”等，而不是addEventListener（）方法中的第一个参数”click” 在DOM0级方法下，事件处理程序会在其所属的作用域内运行；但IE事件处理程序会在全局作用域中运行，attachEvent（）中的this等于window。 attachEvent（）为同一个按钮添加的两个不同事件处理程序的执行顺序与DOM方法中当好相反。 var btn = document.getElementById(&apos;btn&apos;); btn.attachEvent(&quot;onclick&quot;, function(){ alert(&quot;clicked&quot;); }); btn.attachEvent(&quot;onclick&quot;, function(){ alert(&quot;Hello world&quot;); }); 执行这段代码在IE中会首先看到“Hello world!”,然后才是“clicked”. 而若是DOM事件处理程序，则是按照事件处理程序添加的顺序执行的，即先看到”clicked”,然后才是”Hello world！” 对于detachEvent（）来说，和DOM方法中一样，只要将对相同函数的引用传给detachEvent（），就可以移除相应的事件处理程序。 跨浏览器事件处理程序编写跨浏览器的事件处理程序，只需要恰当的使用能力检测即可. 首先会检测是否支持DOM2级事件处理程序，其次检测是否存在IE的方法，最后一种则是DOM0级方法。 事件处理程序注意点： DOM0级事件处理程序只能添加一个事件处理程序 IE事件处理程序是全局运行的 事件对象event属性方法 event.currentTarget是事件处理程序被注册到的元素，等于this 而event.target是事件的实际目标 若需要用同一事件处理程序处理不同的事件，则可用event.type来分别处理 stopPropagation（）方法用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或者冒泡。例如：直接添加到一个按钮的时机处理程序可以调用stopPropagation（），从而避免触发注册在document.body上面的时间处理程序。 var btn = document.getElementById(&apos;btn&apos;); btn.onclick = function(event){ alert(&quot;clicked&quot;); event.stopPropagation(); }; document.body.onclick = function(event) { alert(“body clicked”); }","categories":[],"tags":[]},{"title":"粒子群优化算法学习笔记","slug":"粒子群优化算法学习笔记","date":"2017-02-17T07:40:49.000Z","updated":"2017-02-20T08:56:46.000Z","comments":true,"path":"2017/02/17/粒子群优化算法学习笔记/","link":"","permalink":"https://aiyuzhou.github.io/2017/02/17/粒子群优化算法学习笔记/","excerpt":"","text":"粒子群优化算法原理：从随机解出发，通过迭代寻找最优解，也通过适应度来评价解的品质。PSO是一种随机的、并行的优化算法。PSO算法优点： 不要求被优化函数具有可微、可导、连续等性质，收敛速度较快，算法简单，容易编程实现。 PSO算法缺点： 对于有多个局部极值点的函数，容易陷入到局部极值点中，得不到正确的结果。造成这种现象的原因有两种，其一是由于待优化函数的性质；其二是由于微粒群算法中微粒的多样性迅速消失，造成早熟收敛。这两个因素通常密不可分地纠缠在一起。 由于缺乏精密搜索方法的配合，PSO算法往往不能得到精确的结果。造成这种问题的原因是PSO算法并没有很充分地利用计算过程中获得的信息，在每一步迭代中，仅仅利用了群体最优和个体最优的信息。 PSO算法虽然提供了全局搜索的可能，但并不能保证收敛到全局最优点上。 PSO算法是一种启发式的仿生优化算法，当前还没有严格的理论基础，仅仅是通过对某种群体搜索现象的简化模拟而设计的，但并没有从原理上说明这种算法为什么有效，以及它适用的范围。 当前针对PSO算法开展的研究工作种类繁多，经归纳整理分为如下八个大类： 对PSO算法进行理论分析，试图理解其工作机理； 改变PSO算法的结构，试图获得性能更好的算法； 研究各种参数配置对PSO算法的影响； 研究各种拓扑结构对PSO算法的影响； 研究离散版本的PSO算法； 研究PSO算法的并行算法； 利用PSoriasis算法对多种情况下的优化问题进行求解； 将PSO算法应用到各个不同的工程领域。 对于如何采用计算机构建具有合作行为的群集人工生命系统的五项基本原则： 临近原则：群体应该能够执行简单的空间和时间运算 质量原则：群体应该能感受到周围环境中质量因素的变化，并对其产生响应。 反应多样性原则：群体不应将自己获取资源的途径限制在狭窄的范围之内 稳定性原则：群体不应随着环境的每一次变化而改变自己的行为模式 适应性原则：当改变行为模式带来的回报是值得的时候，群体应该改变其行为模式","categories":[],"tags":[{"name":"粒子群优化算法","slug":"粒子群优化算法","permalink":"https://aiyuzhou.github.io/tags/粒子群优化算法/"}]},{"title":"前端常见问题总结","slug":"前端常见问题总结","date":"2017-02-14T07:46:03.000Z","updated":"2017-02-14T07:46:03.000Z","comments":true,"path":"2017/02/14/前端常见问题总结/","link":"","permalink":"https://aiyuzhou.github.io/2017/02/14/前端常见问题总结/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"手机端以及微信内置浏览器关于H5的开发遇到的问题","slug":"手机端以及微信内置浏览器关于H5的开发遇到的问题","date":"2017-02-14T06:17:08.000Z","updated":"2017-02-15T06:10:17.000Z","comments":true,"path":"2017/02/14/手机端以及微信内置浏览器关于H5的开发遇到的问题/","link":"","permalink":"https://aiyuzhou.github.io/2017/02/14/手机端以及微信内置浏览器关于H5的开发遇到的问题/","excerpt":"","text":"最近在开发一个H5页面，H5嘛都在微信中浏览，所以就神奇的入了微信内置浏览器的坑。 其中有两页是两个视频，理想效果是在滑到那页时自动播放视频，最开始拿到的视频是mov格式，我知道本身H5就没有来支持这个格式，侥幸试了试，在我的手机上可以播放，但不能自动播放，强制点击后全屏播放，诶，我一查全是说iPhone上不能嵌入页面自动播放，找资料查到了iphone-inline-video.min.js，用法可以看这里iphone-inline-video，到这里看来mov格式在我手机上是可以的，结果测试其他iPhone6，6p等等等都不行，侥幸试试嘛，格式是肯定要换的。 所以写了以下： &apos;&lt;video src=&quot;img/movie.mp4&quot; preload=&quot;auto&quot; autoplay=&apos;autoplay&apos; loop=&apos;loop&apos;&gt;&lt;/video&gt;&apos; 提前加载，自动播放，循环播放嘛 然后打开浏览器，什么都没有，真的什么都没有啊。。这里要指明的问题是用任何模拟器调试（指chrome上各种模拟器，还有如果开发微信web所用的微信web开发者工具）都很有可能和真机调试结果不同，比如我在iPhoneSE上可以显示mp4格式，可是微信开发者工具上却是显示不了的，你可以试试加个控制条，会发现控制条在，视频却是没有的。 然后啊，我就去网上先找了个ogg格式的试试，唉，也不行啊。这次是微信web开发者工具上可以显示，手机上不行。 然后我试着在source里分别放mp4和ogg格式： &apos;&lt;video preload=&quot;auto&quot; autoplay=&apos;autoplay&apos; loop=&apos;loop&apos;&gt; &lt;source src=&quot;img/movie.ogg&quot; type=&quot;video/ogg&quot;&gt; &lt;source src=&quot;img/movie.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;/video&gt;&apos; 再测试，微信web开发工具显示ogg格式，手机微信上显示mp4格式（别问我怎么知道的，我的两个视频内容不一样哈哈哈 那我再换顺序 &apos;&lt;video preload=&quot;auto&quot; autoplay=&apos;autoplay&apos; loop=&apos;loop&apos;&gt; &lt;source src=&quot;img/movie.mp4&quot; type=&quot;video/ogg&quot;&gt; &lt;source src=&quot;img/movie.ogg&quot; type=&quot;video/mp4&quot;&gt; &lt;/video&gt;&apos; 结果没变，首先微信web不支持mp4格式，但支持ogg，然而手机微信却相反，首先要说的是，微信web开发者工具做的太烂。。既然你专门做了个开发者工具，就要和微信对应的上，省去开发者强行在微信内置浏览器调试的繁琐过程，真的非常非常繁琐啊。 那么微信内置浏览器到底支持什么格式呢？ 反正mp4是支持的。。ogg按照我这样测试过说明不支持，至于webM还没测试过呢 另外，ios不支持video自动播放，记得调用video.play()","categories":[],"tags":[{"name":"H5","slug":"H5","permalink":"https://aiyuzhou.github.io/tags/H5/"},{"name":"WeChat","slug":"WeChat","permalink":"https://aiyuzhou.github.io/tags/WeChat/"},{"name":"微信内置浏览器","slug":"微信内置浏览器","permalink":"https://aiyuzhou.github.io/tags/微信内置浏览器/"},{"name":"video","slug":"video","permalink":"https://aiyuzhou.github.io/tags/video/"}]},{"title":"静下心来，思考","slug":"静下心来，思考","date":"2016-12-18T09:08:04.000Z","updated":"2017-02-17T07:44:51.000Z","comments":true,"path":"2016/12/18/静下心来，思考/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/18/静下心来，思考/","excerpt":"","text":"生活不易，且行且珍惜就在刚刚挂完和姐姐二姐的电话，突然有一种悲伤涌上心头，眼泪在眼中打转，感觉自己随时可以哭的撕心裂肺，我不知道自己是难过生活的不容易，还是感动姐姐们的关心，从她们的话中就像是你不管有多少困难，都一定要先找她们，而不是自己憋着难过。这种感觉就像是在某个失眠的夜晚，脑海中浮现出小学去学校妈妈送我到校门口，我却没有回头看到妈妈伤心的脸，或者是暴雨中妈妈在流淌的雨水中一步步艰难的背着我们的行李送我们去车站，或者是高三晚自习下课后妈妈在家门外拿着手电筒照明我回家的路，","categories":[],"tags":[{"name":"life","slug":"life","permalink":"https://aiyuzhou.github.io/tags/life/"},{"name":"thinking","slug":"thinking","permalink":"https://aiyuzhou.github.io/tags/thinking/"}]},{"title":"canvas实现小球的弹性碰撞","slug":"bouncing1","date":"2016-12-16T10:02:37.000Z","updated":"2016-12-18T09:31:41.000Z","comments":true,"path":"2016/12/16/bouncing1/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/16/bouncing1/","excerpt":"","text":"写在最前面首先，代码源于supperjet源码: 小球碰撞运动效果图如下：写之前，想一个问题，如果我要写一个box内弹性碰撞的小球的动画，我应该从哪里入手。 先从对象开始考虑，我需要定义ball和box两个对象，ball需要有大小，颜色，所在位置这些属性，box只需要有长宽属性，而在动画中canvas就是box。 考虑碰撞规则 若碰撞到box的上边，则碰撞条件是：ball的中心点坐标 y 小于其自身半径 radius，解决方法是：将ball的中心点坐标 y 置为ball.radius并且ball的垂直运动方向反向 若碰撞到box的下边，则碰撞条件是：ball的中心点坐标 y 与其自身半径 radius之和大于box的height，解决方法是：将ball的中心点坐标 y 置为box.height - ball.radius并且ball的垂直运动方向反向 若碰撞到box的左边，则碰撞条件是：ball的中心点坐标 x 小于其自身半径 radius，解决方法是：将ball的中心点坐标 x 置为ball.radius并且ball的水平运动方向反向 若碰撞到box的右边，则碰撞条件是：ball的中心点坐标 x 与其自身半径 radius之和大于box的width，解决方法是：将ball的中心点坐标 x 置为box.width - ball.radius并且ball的水平运动方向反向 ball的实现是每次运动都重新渲染画布，所以，ball还需要一个draw的方法来完成自身的渲染 代码实现ball对象function Ball(radius,color){ if(radius === undefined) {radius = 40;} if(color === undefined){color = &apos;#00ff00&apos;;} this.x = 0; //中心点坐标x,y this.y = 0; this.vx = 0; //小球的水平及垂直运动方向 this.vy = 0; this.radius = radius; this.color = color; } box对象（即canvas）&lt;canvas id=&apos;canvas&apos; width=&quot;400&quot; height=&quot;300&quot; style=&quot;background:#000&quot;&gt;&lt;/canvas&gt; 碰撞规则ball.x = ball.x + ball.vx; //小球运动 ball.y = ball.y + ball.vy; //碰撞规则 if(ball.y &lt; ball.radius){ ball.y = ball.radius; ball.vy = ball.vy*(-1); } if(ball.y + ball.radius &gt; canvas.height){ ball.y = canvas.height - ball.radius; ball.vy = ball.vy*(-1); } if(ball.x &lt; ball.radius){ ball.x = ball.radius; ball.vx = ball.vx*(-1); } if(ball.x + ball.radius &gt; canvas.width){ ball.x = canvas.width - ball.radius; ball.vx = ball.vx*(-1); } 小球渲染Ball.prototype.draw = function(context){ context.save(); context.translate(this.x,this.y); context.fillStyle = this.color; context.strokeStyle = this.color; context.beginPath(); context.arc(0,0,this.radius,0,Math.PI*2,false); context.closePath(); context.fill(); context.stroke(); context.restore(); }","categories":[],"tags":[{"name":"animation","slug":"animation","permalink":"https://aiyuzhou.github.io/tags/animation/"},{"name":"canvas","slug":"canvas","permalink":"https://aiyuzhou.github.io/tags/canvas/"},{"name":"bouncing","slug":"bouncing","permalink":"https://aiyuzhou.github.io/tags/bouncing/"}]},{"title":"H5-Animation-canvas百分比加载","slug":"H5-Animation-canvas百分比加载","date":"2016-12-16T04:02:41.000Z","updated":"2016-12-16T08:17:59.000Z","comments":true,"path":"2016/12/16/H5-Animation-canvas百分比加载/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/16/H5-Animation-canvas百分比加载/","excerpt":"","text":"首先，代码源于supperjet，我是边看代码边学习记笔记。源码: canvas百分比加载 效果图是这样的: 代码解析drawFrame(function drawFrame(){ window.requestAnimationFrame(drawFrame, canvas); context.clearRect(0, 0, canvas.width, canvas.height); whiteCircle(); text(speed); blueCircle(speed); if(speed &gt; 100) speed = 0; speed += 0.1; }()); window.requestAnimationFrame(drawFrame, canvas);相当于是个递归吧，相当于是canvas每次调用一次drawFrame来重新渲染画布。 clearRect来清除画布内容，其实这里就很清楚了，canvas的动画效果只是视觉上的动画，并非真的一点一点在变，大概意思就是：我要把一段直线从1cm变到2cm，我是先画了1cm的线段，在把这个画布清除，然后在画2cm的线段，而不是视觉上的先画1cm，然后在1cm的基础上再画1cm。 代码解析whiteCirclefunction whiteCircle(){ context.save(); context.beginPath(); context.strokeStyle = &quot;white&quot;; context.arc(centerX, centerY, 100 , 0, Math.PI*2, false); context.stroke(); context.closePath(); context.restore(); console.log(&quot;whiteCircle&quot;); } whiteCircle()用来画白色的底线，底线一直都是完整圆，所以都是0，2π 代码解析textfunction text(n){ context.save(); context.strokeStyle = &quot;#49f&quot;; context.font = &quot;40px Arial&quot;; context.strokeText(n.toFixed(0)+&quot;%&quot;, centerX-25, centerY+10); context.stroke(); context.restore(); } text(speed)用来变化百分比这个n.toFixed(0)四舍五入保留一位，所以是从0~100 代码解析blueCirclefunction blueCircle(n){ context.save(); context.beginPath(); context.strokeStyle = &quot;#49f&quot;; context.lineWidth = 5; context.arc(centerX, centerY, 100 , -Math.PI/2, -Math.PI/2 +n*rad, false); context.stroke(); context.closePath(); context.restore(); } blueCircle(speed)蓝线表示进度条，每次都从-1/2π开始画到-1/2π + speed*rad(rad = 2π/100) window.requestAnimationFrame(drawFrame, canvas)是浏览器来调用的，自然在流畅性上比setInterval和setTimeout好，并且节省资源，如果用setInterval来实现 var timer = setInterval(function () { context.clearRect(0, 0, canvas.width, canvas.height); whiteCircle(); text(speed); blueCircle(speed); if(speed &gt; 100) { speed = 0; //clearInterval(timer);//如果只执行一次，在这里清除句柄就OK } speed += 0.1; },50); 同样window.requestAnimationFrame也会返回唯一表示requestID，可用window.cancelAnimationFrame()来取消回调函数.","categories":[],"tags":[{"name":"H5","slug":"H5","permalink":"https://aiyuzhou.github.io/tags/H5/"},{"name":"animation","slug":"animation","permalink":"https://aiyuzhou.github.io/tags/animation/"},{"name":"canvas","slug":"canvas","permalink":"https://aiyuzhou.github.io/tags/canvas/"}]},{"title":"写在最前面","slug":"写在最前面","date":"2016-12-15T08:29:14.000Z","updated":"2016-12-16T08:25:34.000Z","comments":true,"path":"2016/12/15/写在最前面/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/15/写在最前面/","excerpt":"","text":"终于，我开始写博客了 更新：为什么要写博客，我写博客的重要目的是记笔记，因为平时所谓的看懂了听懂了搞明白了，都是粗略的懂了，但是讲的时候很难讲清楚，我自己本来就有些不善表达，更准确的说是不善于组织语言，所以写博客记笔记的过程中其实是一个很好的思考过程，你要把问题说明白，这对自己来说我觉得是很大的提升，所以，保持一个书写的习惯是非常好的，我以后会把之前写的笔记慢慢整理上来。 写在最前面 除去前两篇的测试文章，这大概算是我非常正式的写在自己的博客里的第一篇文章了，为什么说是大概呢！！！原因是： 我很早很早之前就想开始写博客了，至于多早，应该是我刚刚入门前端的时候吧，那个时候每次在网上搜寻学习过程中遇到的一些问题时，见到不少形式的博客，有写在CSDN的，有博客园的，有简书的，有github的，于是啊，我就萌生了自己写一个博客系统的想法，现在想想真是可笑啊哈哈哈哈哈哈。。。那时用的是javaweb，最后的结果呢，就是写了些静态的漂亮的页面，简单的交互：有阅读全文跳转到整章阅读，在article页面，阅读全文则全部文章的wrap div设置为display：none,单个文章的wrap div设置为display：block，然后js将内容换位点击那篇文章的内容。恩，然后我意识到自己一个人写一个系统不现实，我开始动手写的时候就是脑子一热就开始写了，完全没有考虑到一个博客系统项目架构，模块，数据库存储，到最后部署上线不是我一个刚刚入门的小菜鸟能搞定的，终于认清楚以后，就在这里停下来。 我开始在印象笔记里零零散散的记一些知识，也在电脑创建过文件夹用markdown来记笔记，太零散了，整理的时候真希望有个标签一点就把我要的文章找出来。 所以，在这么长的时间过去之后，我快毕业了，我终于决定搭建我的博客，对，就是今天，斟酌一番后，决定用最简易的github Pages和hexo来搭建博客（之前非常蠢得准备自己写一个博客系统的时候，还没有开始用github，捂脸逃），选了个自己喜欢的主题，就这样我的真正的博客开通了。 记录目前生活状态我是Annie Chou，是一名程序媛，现在就读于西安电子科技大学，于明年7月毕业。目前在北京一家智能硬件创业公司实习，也打算继续留在这里工作。 希望自己可以在前端的路上摸爬打滚越滚越远！","categories":[],"tags":[]},{"title":"linux命令 chmod 755的含义","slug":"linux命令_chmod_755的含义","date":"2016-12-15T04:38:32.000Z","updated":"2016-12-15T05:27:41.000Z","comments":true,"path":"2016/12/15/linux命令_chmod_755的含义/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/15/linux命令_chmod_755的含义/","excerpt":"","text":"linux命令 chmod 755的含义chmod是Linux下设置文件权限的命令，后面的数字表示不同用户或用户组的权限。一般是三个数字：第一个数字表示文件所有者的权限第二个数字表示与文件所有者同属一个用户组的其他用户的权限第三个数字表示其它用户组的权限。 权限分为三种：读（r=4），写（w=2），执行（x=1） 。 综合起来还有可读可执行（rx=5=4+1）、可读可写（rw=6=4+2）、可读可写可执行(rwx=7=4+2+1)。 所以，chmod 755 设置用户的权限为： 1.文件所有者可读可写可执行 –72.与文件所有者同属一个用户组的其他用户可读可执行 –53.其它用户组可读可执行 –5","categories":[],"tags":[{"name":"chmod","slug":"chmod","permalink":"https://aiyuzhou.github.io/tags/chmod/"}]},{"title":"angular学习笔记（一）—— 创建自定义指令","slug":"angular学习笔记（一）——_创建自定义指令","date":"2016-12-15T04:19:32.000Z","updated":"2017-02-14T06:15:49.000Z","comments":true,"path":"2016/12/15/angular学习笔记（一）——_创建自定义指令/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/15/angular学习笔记（一）——_创建自定义指令/","excerpt":"","text":"angular学习笔记（一）—— 创建自定义指令使用驼峰法来命名一个指令， runoobDirective, 但在使用它时需要以 - 分割, runoob-directive:实例： &lt;runoob-directive&gt;&lt;/runoob-directive&gt; &lt;script&gt; var app = angular.module(&quot;myApp&quot;, []); app.directive(&quot;runoobDirective&quot;, function() { return { template : &quot;&lt;h1&gt;自定义指令!&lt;/h1&gt;&quot; }; }); &lt;/script&gt; 元素名 &lt;runoob-directive&gt;&lt;/runoob-directive&gt; 属性 &lt;div runoob-directive&gt;&lt;/div&gt; 类名 &lt;div class=&quot;runoob-directive&quot;&gt;&lt;/div&gt; 注释 &lt;!-- directive: runoob-directive --&gt; 限制使用你可以限制你的指令只能通过特定的方式来调用。 实例 通过添加 restrict 属性,并设置只值为 “A”, 来设置指令只能通过属性的方式来调用: var app = angular.module(&quot;myApp&quot;, []); app.directive(&quot;runoobDirective&quot;, function() { return { restrict : &quot;A&quot;, template : &quot;&lt;h1&gt;自定义指令!&lt;/h1&gt;&quot; }; }); restrict 值可以是以下几种: E 作为元素名使用 A 作为属性使用 C 作为类名使用 M 作为注释使用 restrict 默认值为 EA, 即可以通过元素名和属性名来调用指令。","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"https://aiyuzhou.github.io/tags/angular/"}]}]}