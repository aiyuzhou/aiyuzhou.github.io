{"meta":{"title":"Annie","subtitle":"ah~ha,时间","description":"","author":"Annie Chou","url":"https://aiyuzhou.github.io"},"pages":[{"title":"tags","date":"2016-12-15T04:19:32.000Z","updated":"2016-12-15T05:26:29.000Z","comments":true,"path":"tags/index.html","permalink":"https://aiyuzhou.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CSS常见问题总结","slug":"CSS常见问题总结","date":"2017-04-13T08:29:06.000Z","updated":"2017-04-13T08:30:45.000Z","comments":true,"path":"2017/04/13/CSS常见问题总结/","link":"","permalink":"https://aiyuzhou.github.io/2017/04/13/CSS常见问题总结/","excerpt":"","text":"css相关问题一、display：none和visibility：hidden的区别？ display：none 是隐藏对应的元素，在文档布局中不再给它分配空间 visibility：hidden 隐藏相应元素，但是文档流中位置保存 二、CSS中link和@import的区别？ link 属于HTML标签 页面加载时，link会同时被加载 无兼容性问题 @import 是CSS提供的标签 在页面加载完成后才加载@import引用的CSS文件 只有在IE5以上才可用，低于IE5不兼容 三、IE盒模型和标准W3C盒模型 标准W3C盒模型： 包括margin、border、padding、content，并且content不包含其他部分 content的width = width IE盒模型： 也包括margin、border、padding、content，但是content包括border和padding content的width = width + padding + border 四、CSS选择符有哪些？ id选择器(#myid) 类选择器(.myclassname) 标签选择器(div,h1,p) 相邻选择器(h1 + p) 子选择器(ul &gt; li) 后代选择器(li a) 通配符选择器(*) 属性选择器(a[rel = “external”]) 伪类选择器(a:hover,li:nth-child) 五、CSS可继承的属性 font-size font-family color text-intent 六、CSS不可继承的属性 border padding margin width height 七、CSS优先级! important &gt; id &gt; class &gt; tag 八、CSS3新增的伪类 :first-child选择某个元素的第一个子元素； :last-child选择某个元素的最后一个子元素； :nth-child()选择某个元素的一个或多个特定的子元素； :nth-last-child()选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算； :nth-of-type()选择指定的元素； :nth-last-of-type()选择指定的元素，从元素的最后一个开始计算； :first-of-type选择一个上级元素下的第一个同类子元素； :last-of-type选择一个上级元素的最后一个同类子元素； :only-child选择的元素是它的父元素的唯一一个了元素； :only-of-type选择一个元素是它的上级元素的唯一一个相同类型的子元素； :empty选择的元素里面没有任何内容。 九、为什么要初始化CSS样式因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没有对CSS初始化，往往不同的浏览器之间的页面显示差异。 十、BFC:块级格式化上下文 根元素 float属性不为none position为absolute或fixed display为inline-block,table-cell,table-caption,flex,inline-flex overflow不为visible 在一个BFC的盒子内的子元素的样式不会影响到外面的元素，并且同一个BFC中的两个相邻的块级盒在垂直方向(和布局方向有关系)的margin会发生折叠。 十一、CSS sprite（CSS精灵）图像精灵—是放入一张单独的图片中的一系列图像。大量包含图像的网页需要更长的时间来下载，同时会生成多个服务器请求。使用图像精灵将减少服务器请求数量并节约带宽。虽然请求可以并发，但是也有限制，一般浏览器都是6个。我们将通过CSS的background-image,background-repeat,background-position的组合进行背景定位。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://aiyuzhou.github.io/tags/css/"},{"name":"css3","slug":"css3","permalink":"https://aiyuzhou.github.io/tags/css3/"},{"name":"盒模型","slug":"盒模型","permalink":"https://aiyuzhou.github.io/tags/盒模型/"},{"name":"CSS精灵","slug":"CSS精灵","permalink":"https://aiyuzhou.github.io/tags/CSS精灵/"}]},{"title":"前端基础问题总结","slug":"前端基础问题总结","date":"2017-04-13T04:00:54.000Z","updated":"2017-04-13T08:28:30.000Z","comments":true,"path":"2017/04/13/前端基础问题总结/","link":"","permalink":"https://aiyuzhou.github.io/2017/04/13/前端基础问题总结/","excerpt":"","text":"css相关问题一、display：none和visibility：hidden的区别？ display：none 是隐藏对应的元素，在文档布局中不再给它分配空间 visibility：hidden 隐藏相应元素，但是文档流中位置保存 二、CSS中link和@import的区别？ link 属于HTML标签 页面加载时，link会同时被加载 无兼容性问题 @import 是CSS提供的标签 在页面加载完成后才加载@import引用的CSS文件 只有在IE5以上才可用，低于IE5不兼容 三、IE盒模型和标准W3C盒模型 标准W3C盒模型： 包括margin、border、padding、content，并且content不包含其他部分 content的width = width IE盒模型： 也包括margin、border、padding、content，但是content包括border和padding content的width = width + padding + border 四、CSS选择符有哪些？ id选择器(#myid) 类选择器(.myclassname) 标签选择器(div,h1,p) 相邻选择器(h1 + p) 子选择器(ul &gt; li) 后代选择器(li a) 通配符选择器(*) 属性选择器(a[rel = “external”]) 伪类选择器(a:hover,li:nth-child) 五、CSS可继承的属性 font-size font-family color text-intent 六、CSS不可继承的属性 border padding margin width height 七、CSS优先级! important &gt; id &gt; class &gt; tag 八、CSS3新增的伪类 :first-child选择某个元素的第一个子元素； :last-child选择某个元素的最后一个子元素； :nth-child()选择某个元素的一个或多个特定的子元素； :nth-last-child()选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算； :nth-of-type()选择指定的元素； :nth-last-of-type()选择指定的元素，从元素的最后一个开始计算； :first-of-type选择一个上级元素下的第一个同类子元素； :last-of-type选择一个上级元素的最后一个同类子元素； :only-child选择的元素是它的父元素的唯一一个了元素； :only-of-type选择一个元素是它的上级元素的唯一一个相同类型的子元素； :empty选择的元素里面没有任何内容。 九、为什么要初始化CSS样式因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没有对CSS初始化，往往不同的浏览器之间的页面显示差异。 十、BFC:块级格式化上下文 根元素 float属性不为none position为absolute或fixed display为inline-block,table-cell,table-caption,flex,inline-flex overflow不为visible 在一个BFC的盒子内的子元素的样式不会影响到外面的元素，并且同一个BFC中的两个相邻的块级盒在垂直方向(和布局方向有关系)的margin会发生折叠。 十一、CSS sprite（CSS精灵）图像精灵—是放入一张单独的图片中的一系列图像。大量包含图像的网页需要更长的时间来下载，同时会生成多个服务器请求。使用图像精灵将减少服务器请求数量并节约带宽。虽然请求可以并发，但是也有限制，一般浏览器都是6个。我们将通过CSS的background-image,background-repeat,background-position的组合进行背景定位。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://aiyuzhou.github.io/tags/javascript/"},{"name":"css","slug":"css","permalink":"https://aiyuzhou.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://aiyuzhou.github.io/tags/html/"}]},{"title":"react原理","slug":"react原理","date":"2017-04-13T01:55:29.000Z","updated":"2017-04-13T01:56:14.000Z","comments":true,"path":"2017/04/13/react原理/","link":"","permalink":"https://aiyuzhou.github.io/2017/04/13/react原理/","excerpt":"","text":"原理在普通web开发中，我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端使用JavaScript实现了一套DOM API。 基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树与上次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。 而且React能够批处理虚拟DOM的刷新，在一个事件循环内的两次数据变化会被合并，例如你连续的先将节点内容从A变成B，又从B变成A，react会认为UI没有发生变化， 尽管每一次数据变化都需要构造完整的虚拟DOM树，但因为虚拟DOM是内存数据，性能是极高的，而对实际DOM进行操作的仅仅是diff部分，因而能达到提高性能的目的。 这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到具体的DOM元素，只需要关心任意数据状态下，整个界面是如何render的。 组件化 所谓组件，就是分装起来具有独立功能的UI部件。react以组件的方式去思考UI构成，将UI上的每一个功能相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体UI的构建。 可组合：一个组件易于和其他组件组合在一起使用，或者嵌套在另一个组件内部，如果一个组件内部创建了另一个组件，那么父组件拥有它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件； 可重用：每个组件具有独立的功能，他可以被使用在UI场景； 可维护：每个小组件仅仅包含自身的逻辑，更容易理解和维护。 组件属性 获取属性的值，需要通过this.props 创建组件的名称首字母必须大写 为元素添加CSS的class时，需要用className 组件的style属性的设置方式也值得注意，要写成style= 组件状态react将组件看做一个状态机，一开始有一个初始状态，每次状态变化触发重新渲染UI 组件生命周期 mount：正在或者已经插入真实的DOM update：重新渲染 unmount：已移除真实DOM 每个状态有两种处理函数，will在进入状态前调用，did在进入状态之后调用","categories":[],"tags":[{"name":"react原理","slug":"react原理","permalink":"https://aiyuzhou.github.io/tags/react原理/"}]},{"title":"JavaScript事件-区别IE事件和DOM事件","slug":"JavaScript事件-区别IE事件和DOM事件","date":"2017-04-13T01:54:17.000Z","updated":"2017-04-13T01:54:52.000Z","comments":true,"path":"2017/04/13/JavaScript事件-区别IE事件和DOM事件/","link":"","permalink":"https://aiyuzhou.github.io/2017/04/13/JavaScript事件-区别IE事件和DOM事件/","excerpt":"","text":"IE事件处理程序 IE实现了与DOM2级事件处理程序类似的两个方法：attachEvent（）和detachEvent（）。 这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。 通过attachEvent（）添加的事件处理程序都会被添加到冒泡阶段。 而且attachEvent（）的第一个参数是”onclick”,”onload”等，而不是addEventListener（）方法中的第一个参数”click” 在DOM0级方法下，事件处理程序会在其所属的作用域内运行；但IE事件处理程序会在全局作用域中运行，attachEvent（）中的this等于window。 attachEvent（）为同一个按钮添加的两个不同事件处理程序的执行顺序与DOM方法中当好相反。 var btn = document.getElementById(&apos;btn&apos;); btn.attachEvent(&quot;onclick&quot;, function(){ alert(&quot;clicked&quot;); }); btn.attachEvent(&quot;onclick&quot;, function(){ alert(&quot;Hello world&quot;); }); 执行这段代码在IE中会首先看到“Hello world!”,然后才是“clicked”. 而若是DOM事件处理程序，则是按照事件处理程序添加的顺序执行的，即先看到”clicked”,然后才是”Hello world！” 对于detachEvent（）来说，和DOM方法中一样，只要将对相同函数的引用传给detachEvent（），就可以移除相应的事件处理程序。 跨浏览器事件处理程序编写跨浏览器的事件处理程序，只需要恰当的使用能力检测即可. 首先会检测是否支持DOM2级事件处理程序，其次检测是否存在IE的方法，最后一种则是DOM0级方法。 事件处理程序注意点： DOM0级事件处理程序只能添加一个事件处理程序 IE事件处理程序是全局运行的 事件对象event属性方法 event.currentTarget是事件处理程序被注册到的元素，等于this 而event.target是事件的实际目标 若需要用同一事件处理程序处理不同的事件，则可用event.type来分别处理 stopPropagation（）方法用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或者冒泡。例如：直接添加到一个按钮的时机处理程序可以调用stopPropagation（），从而避免触发注册在document.body上面的时间处理程序。 var btn = document.getElementById(&apos;btn&apos;); btn.onclick = function(event){ alert(&quot;clicked&quot;); event.stopPropagation(); }; document.body.onclick = function(event) { alert(“body clicked”); }","categories":[],"tags":[{"name":"IE事件","slug":"IE事件","permalink":"https://aiyuzhou.github.io/tags/IE事件/"},{"name":"DOM事件","slug":"DOM事件","permalink":"https://aiyuzhou.github.io/tags/DOM事件/"}]},{"title":"javascript闭包","slug":"javascript闭包","date":"2017-04-13T01:52:20.000Z","updated":"2017-04-13T01:52:50.000Z","comments":true,"path":"2017/04/13/javascript闭包/","link":"","permalink":"https://aiyuzhou.github.io/2017/04/13/javascript闭包/","excerpt":"","text":"参考《JavaScript Closures Demystified》原文链接 First-Class Function在计算机语言中，方法或者函数被分为三个等级，其中一等函数就是可以被其他函数当做参数传递的，把这种一等函数当做一种类型一样传递给其他函数调用 var foo = function(){ alert(&apos;Hello World&apos;); } var bar = function(arg){ return arg; } bar(foo)(); 此时的foo方法当作参数传递给bar方法，并且被返回，所以最后的bar(foo)()其实和foo()是一样的。 Inner Functions内部方法就像是私有方法一样，JavaScript中一切皆为对象，所以Inner Functions可以就像是对象的私有方法，外部函数每次被调用，都会有一个内部方法的实例生成。 function add (value1,value2){ function doAdd(operand1,operand2){ return operand1+operand; } return doAdd(value1,valude2); } var foo = add(1,2); 内部方法最重要的一个特性就是可以访问其父函数作用域内的变量和参数等，所以改变以上代码 function add (value1,value2){ function doAdd(){ return value1+value2; } return doAdd(); } var foo = add(1,2); 创建闭包function add (value1){ return function doAdd(value2){ return value1+value2; }; } var increment = add(1); var foo = increment(2);//3 add函数将doAdd函数当做返回值，返回这个内部函数的时候，闭包就被创建了 当add(1)执行的时候，会返回如下代码给increment变量 ### increment = function doAdd(value2){ return 1 + value2; /此时的value1=1被捆绑在第一个被加数上 } 闭包的适用场景使用定时器setTimeout()和setInterval()可以通过参数传递 模拟私有变量在JavaScript中没有私有变量的概念，也就是一个实例对象的属性可以随便修改，一个叫tom的 function Person(name) { this._name = name; this.getName = function() { return this._name; }; } var person = new Person(&quot;Colin&quot;); person._name = &quot;Tom&quot;; person.getName() //returns &quot;Tom&quot; 使用闭包可以模拟私有变量 function Person(name) { var _name = name; this.getName = function() { return _name; }; } var person = new Person(&quot;Colin&quot;); person._name = &quot;Tom&quot;; person.getName(); //returns &quot;Colin&quot; person._name is &quot;Tom&quot; but person.getName() returns &quot;Colin&quot; 什么情况下不适合用闭包不应该用在循环中for (var i = 1; i &lt; 4; i++) { var button = document.getElementById(&quot;button&quot; + i); button.addEventListener(&quot;click&quot;, function() { alert(&quot;Clicked button &quot; + i); }); } 这种情况下当你点击按钮时，循环已经执行完了，i已经增到最终值，得不到预想结果 function getHandler(i) { return function handler() { alert(&quot;Clicked button &quot; + i); }; } for (var i = 1; i &lt; 4; i++) { var button = document.getElementById(&quot;button&quot; + i); button.addEventListener(&quot;click&quot;, getHandler(i)); } 修改成以上代码就可以得到预想结果了 闭包不应该用在构造函数上像下面这种情况，每次创建一个实例就会创建一个sayHello的方法 function Person(name) { var _name = name; this.getName = function() { return _name; }; this.sayHello = function() { alert(&quot;Hello!&quot;); }; } 这种情况下应该将sayHello放在构造函数的原型属性对象中，成为实例共享的方法 闭包的特点 闭包是一个可以访问创建它的函数（父函数）作用域的一个函数 闭包是被外部函数暴露给外部函数之外作用域的一个内部函数 闭包可以被用来当做参数传递给回调函数 闭包可以迷你私有作用域 闭包不建议被滥用于构造函数中，建议将其添加到原型属性对象中","categories":[],"tags":[{"name":"闭包","slug":"闭包","permalink":"https://aiyuzhou.github.io/tags/闭包/"}]},{"title":"浏览器缓存方法","slug":"浏览器缓存方法","date":"2017-04-13T01:51:06.000Z","updated":"2017-04-13T01:51:37.000Z","comments":true,"path":"2017/04/13/浏览器缓存方法/","link":"","permalink":"https://aiyuzhou.github.io/2017/04/13/浏览器缓存方法/","excerpt":"","text":"http缓存http缓存是基于http协议的浏览器文件级缓存机制。即针对文件的重复请求情况下，浏览器可以根据协议头判断服务器请求文件还是本地读取文件，chrome控制台下的frames中就是浏览器的http文件级缓存。以下是浏览器缓存的整个机制流程，主要是针对重复的http请求，在有缓存的情况下判断过程主要分3步： 判断expires，如果未过期，直接读取http缓存文件，不发http请求，否则进入下一步。 判断是否含有etag，有则带上if-none-match发送请求，未修改返回304，修改返回200，否则进入下一步。 判断是否含有last-modified，有则带上if-modified-since发送请求，无效返回200，有效返回304，否则直接向服务器发送请求。 websqlwebsql这种方式只有较新的chrome浏览器支持。 将数据以数据库的形式存储在客户端，根据需求去读取 不同于storage的是，storage和cookie都是以键值对的形式存在的 websql允许SQL语句查询 websql API主要包含三个核心方法： openDatabase：这个方法使用现有数据库或创建新数据库 transaction：这个方法允许我们根据情况控制事务提交或回滚 executeSql：执行真实的SQL查询 indexDBcookiecookie指一般网站为了辨识用户身份，进行session跟踪而存储在用户本地终端上的数据（通常经过加密）。cookie一般通过http请求中头部一起发送到服务的，一条cookie记录主要由键、值、域、过期时间、大小组成，一般用来保存用户的认证信息。cookie最大长度和域名个数由不同浏览器决定。 localStoragelocalStorage是HTML5的一种新的本地缓存方案，目前用的比较多，不适合放过多的数据。 sessionStoragesessionStorage和localStorage类似，但是浏览器关闭则会全部删除，API和localStorage相同，实际项目中使用较少。 application cacheapplication cache是将大部分图片资源、js、css等静态资源放在manifest文件配置中。当页面打开时通过manifest文件来读取本地文件或是请求服务器文件。","categories":[],"tags":[{"name":"浏览器端缓存","slug":"浏览器端缓存","permalink":"https://aiyuzhou.github.io/tags/浏览器端缓存/"}]},{"title":"数据结构总结","slug":"数据结构总结","date":"2017-04-13T01:50:11.000Z","updated":"2017-04-13T01:50:41.000Z","comments":true,"path":"2017/04/13/数据结构总结/","link":"","permalink":"https://aiyuzhou.github.io/2017/04/13/数据结构总结/","excerpt":"","text":"数据结构是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。算法是为求解一个问题需要遵循的、被清楚指定的简单指令的集合。数据结构一、线性表线性表是最常用且最简单的一种数据结构，它是n个数据元素的有限序列。实现线性表的方式一般有两种，一种是使用数组存储线性表的元素，即用一组连续的存储单元一次存储线性表的数据元素。另一种是使用链表存储线性表的元素，即用一组任意的存储单元存储线性表的数据元素（存储单元可以是连续的，也可以是不连续的）1、数组实现数组是一种大小固定的数据结构，对线性表的所有操作都可以通过数组来实现。虽然数组一旦创建后大小无法改变，但是当数组不能再存储线性表中的新元素时，我们可以创建一个新的大的数组来替换当前的数组，这样其实可以用数组实现动态的数据结构。在数组位置index上添加元素e的Java代码实现： //假定当前存储元素的数组是oldArray //当前元素的个数是size public void add(int index,int e){ if(index &gt; size || index &lt; 0){ //不合法 } if(size &gt;= oldArray.length){ //数组扩容 } //将数组元素从位置index开始的所有元素往后移一位 for(int i = size-1 ; i &gt;= index; i--){ oldArray[i+1] = oldArray[i]; } oldArray[index] = e; size++; } 数组实现的线性表的优点：可以通过下标来访问或者修改元素，比较高效缺点：在于插入和删除的花费开销比较大，比如在第一个位置前插入一个元素，那么首先要把所有的元素往后移动一个位置。为了提高在任意位置添加或者删除元素的效率，可以采用链式结构来实现线性表。 2、链表链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列节点组成，这些节点不必再内存中相连。每个节点由数据部分Data和链部分Next，Next指向下一个节点，这样当添加或者删除时，只需要改变相关节点的Next的指向，效率很高。（这里主要以单链表为例，暂时不考虑双链表和循环链表）以下是用java实现单链表的定义和一些简单的操作 链表的节点 class Node{ E item; Node&lt;E&gt; next; Node(E element){ this.item = element; this.next = null; } } 对头节点和尾节点进行初始化 //头节点和尾节点都为空，链表为空 Node&lt;E&gt; head = null; Node&lt;E&gt; tail = null; 空链表创建一个新节点 //创建一个新的节点，并让head指向此节点 head = new Node(&apos;nodedata1&apos;); //让尾节点也指向此节点 tail = head; 链表追加一个节点 //创建新节点，同时和最后一个节点连接起来 tail.next = new Node(&apos;nodedata2&apos;); //尾节点指向新的节点 tail = tail.next; 顺序遍历链表 Node&lt;String&gt; current = head; while(current != null){ System.out.println(current.item); current = current.next; } 倒序遍历链表 static void printListRev(Node&lt;String&gt; head)) { //倒序遍历链表主要用了递归的思想 if(head != null){ printListRev(head.next); System.out.println(head.item); } } 单链表反转 //单链表反转 主要是逐一改变两个节点间的链接关系来完成 static Node&lt;String&gt; reList(Node&lt;String&gt; head){ if(head == null){ return null; } Node&lt;String&gt; nodeResult = null; Node&lt;String&gt; nodePre = null; Node&lt;String&gt; current = head; while(current != null){ Node&lt;String&gt; nodeNext = current.next; if(nodeNext == null){ nodeNext = current; } current.next = nodePre; nodePre = current; current = nodeNext; } return nodeResult； } 链表的实现还有其他的方式，常见的还有循环单链表，双向链表，循环双向链表。循环单链表：链表的最后一个节点指向第一个节点，整体构成一个链环双向链表：每个节点中包含两个指针部分，一个指向前驱元，一个指向后继元，(JDK中linkedList集合类的实现就是双向链表循环双向链表：最后一个节点指向第一个节点 二、栈与队列栈和队列也是比较常见的数据结构，它们是特殊的线性表，对于栈来说，访问、插入、删除元素只能在栈顶进行，对于队列来说，元素只能从队列队尾插入，从队列头访问和删除。1、栈栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈顶，对栈的基本操作有push（进栈）和pop（出栈），前者相当于插入，后者相当于删除最后一个元素。栈有时又叫作LIFO（last in first out）表，即后进先出。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://aiyuzhou.github.io/tags/数据结构/"}]},{"title":"常用算法总结","slug":"常用算法总结","date":"2017-04-13T01:49:18.000Z","updated":"2017-04-13T01:49:43.000Z","comments":true,"path":"2017/04/13/常用算法总结/","link":"","permalink":"https://aiyuzhou.github.io/2017/04/13/常用算法总结/","excerpt":"","text":"衡量一个算法的优劣： 时间复杂度：一个算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，该算法的时间复杂度是：T(n)=O(f(n))，表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同 空间复杂度：一个算法在运行过程中临时占用存储空间的大小的量度 查找算法一、顺序查找从查找表的最后一个元素开始逐个与给定关键字比较，若某个记录的关键字与给定值比较相等，则查找成功；否则，若直至第一个记录，都没有相等的值，则查找失败 二、二分查找二分查找是针对有序表的一种查找方式，比较次数少，查找速度快，平均性能好 时间复杂度是：O(logn) 三、二叉树查找基本思想：对查找表的数据进行生成树，确保左分支的值小于右分支的值，二叉查找树也叫二叉搜索树，是一棵空树或者具有以下性质的二叉树： 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树。 性质：对二叉查找树进行中序遍历，即可得到有序的数列 四、分块查找算法思想：将n个数据元素”按块有序”划分为m块，每块中的节点不必有序，但是块与块之间必须按块有序，，即第n-1块中任一元素的关键字都必须小于第n块中的任一元素的关键字。 五、哈希查找哈希表由三部分构成：哈希函数，哈希表和冲突处理 排序算法冒泡排序（稳定的排序）基本思想：假设排序序列的铲毒为n，则进行n-1次遍历，每次从开始位置依次往后比较相邻元素，这样较大的元素往后移，n-1次遍历结束后序列有序 最佳情况：只需遍历一次确定数组已经有序，所以最佳情况时间复杂度是：O(n)最坏情况：需要遍历n-1次，最坏情况时间复杂度是：O(n^2)) 需要注意的是：如果在某次遍历中没有发生交换，那么就不必进行下次遍历了，因为序列已经有序了// 冒泡排序 注意 flag 的作用 static void funBubbleSort(int[] array) { boolean flag = true; for (int i = 0; i &lt; array.length - 1 &amp;&amp; flag; i++) { flag = false; for (int j = 0; j &lt; array.length - 1 - i; j++) { if (array[j] &gt; array[j + 1]) { int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; flag = true; } } } for (int i = 0; i &lt; array.length; i++) { System.out.println(array[i]); } } 简单选择排序（不稳定排序）算法思想：进行n-1次选择，第一次选择最小的放在第一个位置，第二次选择次小的放在第二个位置，以此类推 static void funSelectionSort(int[] array) { for (int i = 0; i &lt; array.length - 1; i++) { int mink = i; // 每次从未排序数组中找到最小值的坐标 for (int j = i + 1; j &lt; array.length; j++) { if (array[j] &lt; array[mink]) { mink = j; } } // 将最小值放在最前面 if (mink != i) { int temp = array[mink]; array[mink] = array[i]; array[i] = temp; } } for (int i = 0; i &lt; array.length; i++) { System.out.print(array[i] + &quot; &quot;); } } 直接插入排序算法思想：将一个记录插入到已经排好序的有序表中，从而得到一个记录数增1的有序表 最好情况：待排序序列已经有序，需要n-1次比较，不需要移动，时间复杂度为O(n)最坏情况：刚好是逆序，时间复杂度为O(n^2)平均情况：时间复杂度为O(n^2) static void funDInsertSort(int[] array) { int j; for (int i = 1; i &lt; array.length; i++) { int temp = array[i]; j = i - 1; while (j &gt; -1 &amp;&amp; temp &lt; array[j]) { array[j + 1] = array[j]; j--; } array[j + 1] = temp; } for (int i = 0; i &lt; array.length; i++) { System.out.print(array[i] + &quot; &quot;); } } 归并排序算法思想：将待排序序列分为两部分，对每部分递归应用归并排序，在两部分都排好后进行合并 时间复杂度：O(nlogn) //归并排序 static void funMergeSort(int[] array) { if (array.length &gt; 1) { int length1 = array.length / 2; int[] array1 = new int[length1]; System.arraycopy(array, 0, array1, 0, length1); funMergeSort(array1); int length2 = array.length - length1; int[] array2 = new int[length2]; System.arraycopy(array, length1, array2, 0, length2); funMergeSort(array2); int[] datas = merge(array1, array2); System.arraycopy(datas, 0, array, 0, array.length); } } //合并两个数组 static int[] merge(int[] list1, int[] list2) { int[] list3 = new int[list1.length + list2.length]; int count1 = 0; int count2 = 0; int count3 = 0; while (count1 &lt; list1.length &amp;&amp; count2 &lt; list2.length) { if (list1[count1] &lt; list2[count2]) { list3[count3++] = list1[count1++]; } else { list3[count3++] = list2[count2++]; } } while (count1 &lt; list1.length) { list3[count3++] = list1[count1++]; } while (count2 &lt; list2.length) { list3[count3++] = list2[count2++]; } return list3; } 快速排序算法思想：在待排序的序列中选择一个称为主元的元素，将数组分为两部分，使得第一部分中的所有元素都小于或等于主元，而第二部分的所有元素都大于主元，然后对两部分递归进行快速排序 快排中需要注意：比较关键的一个部分是主元的选择 // 快速排序 static void funQuickSort(int[] mdata, int start, int end) { if (end &gt; start) { int pivotIndex = quickSortPartition(mdata, start, end); funQuickSort(mdata, start, pivotIndex - 1); funQuickSort(mdata, pivotIndex + 1, end); } } // 快速排序前的划分 static int quickSortPartition(int[] list, int first, int last) { int pivot = list[first]; int low = first + 1; int high = last; while (high &gt; low) { while (low &lt;= high &amp;&amp; list[low] &lt;= pivot) { low++; } while (low &lt;= high &amp;&amp; list[high] &gt; pivot) { high--; } if (high &gt; low) { int temp = list[high]; list[high] = list[low]; list[low] = temp; } } while (high &gt; first &amp;&amp; list[high] &gt;= pivot) { high--; } if (pivot &gt; list[high]) { list[first] = list[high]; list[high] = pivot; return high; } else { return first; } } 堆排序堆的定义：n个关键字序列K1，K2，…，Kn称为堆，当且仅当该序列满足如下性质： ki &lt;= k(2i)且ki &lt;= k(2i+1)(1&lt;=i&lt;=n/2) 满足该性质称之为小顶堆 ki &gt;= k(2i)且ki &gt;= k(2i+1)(1&lt;=i&lt;=n/2) 满足该性质称之为大顶堆 堆的含义表明：完全二叉树中所有的非终端节点的值均不大于（或不小于）其左右孩子节点的值 堆排序的主要思想：每次将根节点与非有序序列的最后一个元素交换，并且每次都将非有序序列调整为大顶堆或者小顶堆，最终实现堆排序 常用算法性能分析","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://aiyuzhou.github.io/tags/算法/"}]},{"title":"ES6学习笔记","slug":"ES6学习笔记","date":"2017-04-13T01:48:17.000Z","updated":"2017-04-13T01:48:49.000Z","comments":true,"path":"2017/04/13/ES6学习笔记/","link":"","permalink":"https://aiyuzhou.github.io/2017/04/13/ES6学习笔记/","excerpt":"","text":"ES6是一个泛称，ECMAScript是JavaScript的标准，JavaScript可以说是ECMAScript的一种实现 let和const命令let一、let声明的变量只在let命令所在的代码块内有效{ let a = 10; var b = 1; } a // a is not defined b //1 二、let适合用在for循环的计数器中for(let i = 0; i &lt; 10; i++){} console.log(i); // i is not defined ### //用var声明，最后输出的是10 var a = []; for (var i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a6; // 10 //用let声明，最后输出的是6 var a = []; for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 6 注： for循环有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域for (let i = 0; i &lt; 3; i++) { let i = &apos;abc&apos;; console.log(i); //输出三次abc } 三、let声明的变量不存在变量提升我们都很熟悉的var命令会发生“变量提升”现象，即变量在声明之前使用，值为undefined，这种现象虽然用着比较友好，但是不符合一般逻辑，变量应该在声明语句之后才能使用。 而let将改变了语法行为，不存在变量提升，let声明的变量一定要在声明后使用，否则将会报错。console.log(foo); //输出undefined var foo = 2; console.log(bar); //报错ReferenceError let bar = 2; 四、暂时性死区只要在块级作用域内存在let命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。 var tmp = 123; if (true) { tmp = &apos;abc&apos;; // ReferenceError let tmp; } 在上述代码中，按理来说{}作用域内可以访问外部变量tmp的，但是由于块内let也声明了tmp变量，所以变量tmp就绑定到这个块作用域内，不再受外部的影响。 在代码块内，使用let命令声明变量钱，该变量即使在外部也被声明过，但是是不可用的，在语法上，称为“暂时性死区”。总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取的，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。五、不允许重复声明let不允许在相同作用域内，重负声明同一个变量，以下情况都是不允许的： function (){ let a = 10; let a = 1; } function (){ let a = 10; var a = 1; } function func(arg){ let arg; } 六、let为JavaScript新增了块级作用域为什么需要块级作用域ES5只有全局作用域和函数作用域，没有块级作用域 内层变量覆盖外层变量 var tmp = new Date(); function func(){ console.log(tmp); if(false){ var tmp = &quot;hello world&quot;; } } func();//undefined 上面代码原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量，但是，由于变量提升，导致内部的tmp变量覆盖了外层的tmp变量。 用来计数的循环变量泄露为全局变量 var s = &quot;hello&quot;; for(var i = 0; i &lt; s.length; i++){ console.log(s[i]); } console.log(i); //s 循环结束后，它并没有消失，泄露成了全局变量。 ES6的块级作用域let 实际上为JavaScript新增了块级作用域 function f1(){ let n = 5; if(true){ let n = 10; } console.log(n); } 上面的函数有两个代码块，都声明了变量n，运行后输出5，这表明外层代码块不受内层代码块的影响。如果使用var变量n，最后输出的值就是10。 块级作用域的出现，使得立即执行函数表达式不再必要了。(function(){ var tmp = 1; ... }()); //相当于 { let tmp = 1; ... } const命令const声明一个只读的常量，一旦声明，常量的值就不能改变。这也意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 const实际保证的是变量指向的那个内存地址不得改动，并不是变量的值不可改动，即只能保证这个指针是固定的，至于它指向的数据结构，是不能保证的。 const foo = {}; foo.prop = 123; //改变数据结构是没问题的，因为它的地址没变 foo = {}; //报错 ### const a = []; a.push(&quot;hello&quot;);//可执行 a.length = 0; //可执行 a = [&quot;world&quot;];//报错 ES6声明变量有六种方法 var function let const import class 顶层对象的属性在ES5中，顶层对象的属性和全局变量等价，ES6改变了这一点，为了保持兼容： var 和 function 命令声明的全局变量，依旧是顶层对象的属性； 另一方面规定，let命令，const命令，class命令声明的全局变量不属于顶层对象的属性。 变量的解构赋值ES6允许“模式匹配”法赋值，即只要等号两边模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://aiyuzhou.github.io/tags/ES6/"}]},{"title":"JavaScript典型问题总结（二）","slug":"JavaScript典型问题总结（二）","date":"2017-04-13T01:46:24.000Z","updated":"2017-04-13T04:00:17.000Z","comments":true,"path":"2017/04/13/JavaScript典型问题总结（二）/","link":"","permalink":"https://aiyuzhou.github.io/2017/04/13/JavaScript典型问题总结（二）/","excerpt":"","text":"关于JavaScript作用域一、考虑以下代码的输出 (function(){ var a = b = 5; }) console.log(b); //5 问题解析：在立即执行函数表达式中，有两个赋值，但其中变量a使用关键词var来声明。意味着a是函数的局部变量。而b被分配给全局作用域 但是需要注意的是：在严格模式（’use strict’）下，代码则会报错，b is not defined 二、考虑以下代码的输出：可对照关于JavaScript参数传递的第二题 var flag = 0; function increase(){ flag++; } increase(); console.log(flag); //1 问题解析：在函数increase作用域之内可以访问到全局作用域的flag值，并且可以修改全局变量的值，所以flag的值递增为1 关于JavaScript参数传递一、考虑以下代码的输出：可对照关于JavaScript作用域的第二题 var flag = 0; function increase(flag){ flag++; } increase(); console.log(flag); //0 问题解析：flag传入函数increase中赋值给函数内部变量flag，并且自加，但JavaScript中参数传递只是值传递，并非引用传递，所以外部flag不会变，还是0 二、考虑以下代码的输出 var obj = {&quot;key&quot;:&quot;1&quot;,&quot;value&quot;:&quot;2&quot;}; var newObj = obj; newObj.value += obj.key; alert(obj.value); //21 这里首先要注意的是obj是对象，引用类型赋值时，实际上是指向同一个对象，所以newObj指向obj对象，当newObj属性value值变为‘21’时，obj的value也变为‘21’，这里也考察了字符串拼接直接可以用+运算实现 关于JavaScript中数组操作方法一、考虑以下代码输出 var a = [1,2,3,4,5]; var b = a.splice(1,3,5,2,1); console.log(a);//[1,5,2,1,5] 问题解析： 分析splice的参数，第一项为1，表示从第1个参数开始 第二个参数为3，表示要删除3项，结合第一个参数，表明从第一个位置开始删除3项元素 之后的三个参数作为新元素将被添加在指定位置，结合第一个参数为1，表明在第一个位置添加这三项 关于JavaScript原型，继承，重写，扩展一、在String对象上定义一个repeatify函数。这个函数接受一个整数参数，来表明字符串需要重复几次，例如： console.log(&quot;hello&quot;.repeatify(3)); //打印出来是hellohellohello 代码实现：String.prototype.repeatify = String.prototype.repeatify || function(times){ var str = &apos;&apos;; for(var i = 0; i &lt; times; i++){ str += this; } return str; } 这里既可以考察对JavaScript中继承及原型属性的了解，也可以考察到如何扩展JavaScript方法。扩展这个技术是非常重要的，避免重写可能已经定义的方法。 二、手写一个js继承 function person(){ this.type = &quot;person&quot;; } function student(name){ person.apply(this,arguments); this.name = name; } 三、js继承中父类如果抛出异常如何解决？比如父类要求定长的参数，不满足时会抛出异常，此时如何处理？ function foo(){ if(arguments.length&gt;=5){ ... }else{ throw new RangeError(&quot;参数长度不正确，请输入规定长度的参数...&quot;) } } function sub(){ foo.apply(this,arguments) } //生成实例时，用try{}catch(error){} try{ var o = new sub(); }catch(error){ throw new Error(父类出错...) } 关于JavaScript的函数提升，变量提升一、执行以下代码输出结果 function test(){ console.log(a); console.log(foo()); var a = 1; function foo(){ return 2; } } test(); //undefined 2 问题解析：这里打印出来undefined和2是由于变量提升和函数提升，以上代码相当于 function test(){ var a; function foo(){ return 2; } console.log(a); console.log(foo()); a = 1; } test(); //undefined 2 变量提升 变量提升：变量声明提升到它所在作用域的最开始部分，但只是提升变量声明，并没有赋值 函数提升 在JavaScript中有两种创建函数的方法：函数声明式和函数字面量，而函数提升只针对函数声明 函数提升：将整个函数代码块提升到文件作用域或者文件最开始的位置 关于JavaScript中this的工作方式详见：JavaScript典型问题（一）中的JavaScript中的this部分 一、以下代码输出结果： var name = &quot;window.name&quot;; var obj = { name : &quot;obj.name&quot;, props : { name : &quot;obj.props.name&quot;, getname : function(){ return this.name; } } } console.log(obj.props.getname()); //obj.props.name var test = obj.props.getname; console.log(test()); //window.name 问题解析：this变量所指对象取决于——函数是如何被调用，而不是如何被定义，或者说this并不是被定义的，只是在函数执行时间内生成的一个执行调用该函数的对象的一个变量 第一次输出obj.props.name，是因为调用getname函数的对象是obj.props这个属性对象，所以执行期间函数内部变量this指向obj.props对象，所以this.name的值为obj.props.name 第二次输出window.name，是因为函数getname被赋值给test这个全局变量，而test变量是属于window对象的，所以执行期间函数内部变量this执行window对象，所以this.name的值为window.name 二、针对上一题的代码，使其打印的值为obj.name var name = &quot;window.name&quot;; var obj = { name : &quot;obj.name&quot;, props : { name : &quot;obj.props.name&quot;, getname : function(){ return this.name; } } } console.log(obj.props.getname.apply(obj)); //或者 // var test = obj.props.getname; // console.log(test.apply(obj)); 问题解析：由于JavaScript中的this指代对象取决于函数被调用的方式，this指代调用函数的对象，所以可用apply和call的特性，让函数在指定对象作用域内运行，即可得到指定对象的name值 关于JavaScript中的闭包一、考虑下面代码，如果我点击第一个和第四个按钮，控制台打印的数据是多少？为什么？ var nodes = document.getElementsByTagName(&apos;button&apos;); for(var i = 0; i &lt; nodes.length; i++){ nodes[i].addEventListener(&apos;click&apos;,function(){ console.log(&apos;You clicked element #&apos; + i); } } 问题解析，打印的始终是nodes.length 二、针对上面问题，使得点击第n个按钮输出n-1 使用立即执行函数表达式再创建一个闭包 var nodes = document.getElementsByTagName(&apos;button&apos;); for(var i = 0; i &lt; nodes.length; i++){ nodes[i].addEventListener(&apos;click&apos;,(function(i){ return function(){ console.log(&apos;You clicked element #&apos; + i); } })(i)); } 问题解析：当立即执行函数传入i值会返回一个函数，并且函数的内容是固定的，传入0时，返回函数是 function(){ console.log(&apos;You clicked element #&apos; + 0); } 并且被绑定在第i个节点nodes[i]上，所以点击时会得到预期的结果 将函数移至循环外面，这种方法由下面的代码实现： function handlerWrapper(i) { return function() { console.log(&apos;You clicked element #&apos; + i); } } var nodes = document.getElementsByTagName(&apos;button&apos;); for (var i = 0; i &lt; nodes.length; i++) { nodes[i].addEventListener(&apos;click&apos;, handlerWrapper(i)); } 三、考虑以下代码的输出 function Foo(){ var i=0; return function(){ document.write(i++); } } var f1=Foo(), f2=Foo(); f1(); //0 f1(); //1 f2(); //0 问题解析：变量f1和f2都是外部函数返回的闭包，并且i都被绑定为数值1，所以首次执行均为0，f1第二次执行，因为闭包对外部函数变量的依赖导致i存储在内存中，所以i继续自加为1 关于JavaScript中的数据类型检测关于检测数据类型以及各种检测方法，详见JavaScript典型问题总结（一）中JavaScript数据类型检测部分一、考虑如下代码的输出结果： console.log(typeof null); //object console.log(typeof {}); //object console.log(typeof []); //object console.log(typeof undefined); //undefined 问题解析： JavaScript中简单数据类型有Undefined，Null，Boolean，Number，String，剩下的均是Object，是引用类型， 而Undefined只有一个值undefined，所以检测undefined时Undefined类型， 而Null只有一个值null，但它表示空对象的引用，所以检测结果是object， 数组类型用typeof只能检测到是个对象，要准确检测是否为数组，课可以通过原型构造函数类型检测， if([].constructor === Array){…} if([].proto.constructor === Array){…} 或者实例检测 if([] instanceof Array){…} 二、考虑以下代码的输出结果： var a=&quot;undefined&quot;; var b=&quot;false&quot;; var c=&quot;&quot;; function assert(aVar){ if(aVar) alert(true); else alert(false); } assert(a); assert(b); assert(c); 详细见《JavaScript典型问题总结(一)》中JavaScript基本数据类型中Boolean的隐式转换。 流控制语句会自动调用Boolean()对流控制语句括号内部分进行隐式转换，而字符串类型的转换过规则是，除了空字符串转换为false，其他非空字符串都转换为true。 关于JavaScript中的事件循环原理一、分析以下代码的输出结果 function printing(){ console.log(1); setTimeout(function(){console.log(2)},1000); setTimeout(function(){console.log(3)},0); console.log(4); } printing(); //1 4 3 2 问题解析：浏览器有一个事件循环用于检查事件队列，处理延迟的事件、UI事件、Ajax回调以及定时器的回调。 按照代码执行顺序，执行第一行，首先输出1 紧接着执行第二行，则将定时器的回调事件处理程序放入事件队列中 接下来执行第三行，虽然延迟时间设置为0，但依然会放入事件队列中排队，注意：此时虽然0秒时间已经过去了，但JavaScript还在执行别的动作，所以不会立即执行这个回调函数 紧接着第四行输出4 然后才去处理事件队列中的函数，由于第三行代码的回调函数等待时间0秒时间已经到了，所以先输出3，然后才输出2 简单算法的实现注意事项： 一定要仔细读题，看清楚测试用例的格式，比如有没有逗号（,）、有没有空格（ ）等等细节问题 读题之后一定要先分析问题的特殊情况 比如，要不要检测参数类型 有没有特殊值 有没有什么方法可以节省运行时间等 然后才开始写程序 一、写一个isPrime()函数，当其为质数时返回true，否则返回false 分析问题： 首先应该检测传入的值是否是一个数值型 其次，分析质数的性质，质数的定义：一个只有1和本身的非负数两个因子 先检测是否是正负性，是否为1和0 偶数除了2以外其他都不是质数 奇数需要单独检测 实现代码如下： function isPrime(num){ if(typeof(num)!==&quot;number&quot;) return; if(num &lt; 2) return false; if(num === 2) { return true; } else if(num%2 === 0) { return false; } for(var i = 2; i &lt;= Math.sqrt(num); i++){ if(num%i === 0) return false; } return true; } 添加代码块一、若要使得a.name = “name1”;b.name = “name2”，填写代码块1和代码块2 function obj(name){ if(name){ this.name = name;}return this;//代码块1 } obj.prototype.name= &quot;name2&quot;; //prototype.name为代码块2 var a = obj(&quot;name1&quot;); var b = new obj; http请求头的connection:keep-alive是什么作用？与TCP的keep-alive的区别？ http协议采用“请求-应答”模式，当使用普通模式，即非keepalive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（http协议为无连接的协议） 当使用keep-alive模式（又称持久连接，连接重用）时，keep-alive功能使客户端到服务器的连接持续有效，当出现对服务器的后继请求时，keep-alive功能避免了建立或者重新建立连接。 启用keep-alive的优点： 更高效，性能更高。 避免了建立/释放连接的开销 从输入URL到显示页面的过程 浏览器查找域名的IP地址，通过访问的域名找出其IP地址，DNS查找过程如下 浏览器缓存—浏览器会缓存DNS记录一段时间，但是没有标准，每个浏览器各自会存储固定的时间 系统缓存—如果浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用。这样便可以获得系统缓存中的记录。 路由器缓存—接着，前面的查询请求发向路由器，路由器一般会有自己的DNS缓存。 ISP DNS缓存—接下来要检查的就是ISP缓存DNS的服务器，在这次查询中一般都能找到相应的缓存记录。（ISP指的是互联网服务提供商） 浏览器给web服务器发送一个http请求 请求网址服务器的永久重定向 浏览器跟踪重定向地址 服务器“处理”请求 服务器返回一个HTML响应 浏览器开始显示HTML 浏览器发送获取请求来活动一些嵌入的文件 cookie、localStorage、sessionStoragecookie 每个cookie都是一个名/值对，要一次性存储多个cookie需要用分号隔开。 如果值中不可避免的使用；，=以及空格，则需要用escape函数进行编码，读取时用unescape来解码 可设置有效时间，用expires字段保存，所以若要删除一个cookie将其expires字段设置为一个过去的时间即可，若不设定过期时间，即当浏览器关闭时cookie自动消失。 缺点：cookie为持久化存储提供了方便，分担了服务器存储的负担，但还是有很多局限性的： ‘cookie’数量和长度的限制，每个domain最多可以有20条cookie，每个cookie长度不能超过4kb，否则会被截掉 sessionStoragesessionStorage是针对一个session进行数据存储，当用户关闭浏览器窗口后，数据会被删除。 localStoragelocalStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://aiyuzhou.github.io/tags/javascript/"}]},{"title":"JavaScript典型问题总结（一）","slug":"JavaScript典型问题总结（一）","date":"2017-04-13T01:44:53.000Z","updated":"2017-04-13T01:46:10.000Z","comments":true,"path":"2017/04/13/JavaScript典型问题总结（一）/","link":"","permalink":"https://aiyuzhou.github.io/2017/04/13/JavaScript典型问题总结（一）/","excerpt":"","text":"JavaScript数据类型JavaScript检测类型检测数据类型有typeof、instanceof等方式 typeof是检测字符串、数值、布尔值还有undefined的最佳工具，还可以检测function类型，并且typeof返回值都是字符串形式， var str = &quot;hhhh&quot;; var b = true; var num = 22; var u; var n = null; var obj = new Ojbect(); var fun = function(){}; console.log(typeof(str)); //string console.log(typeof(b)); //boolean console.log(typeof(num)); //number console.log(typeof(u)); //undefined console.log(typeof(n)); //object console.log(typeof(obj)); //object console.log(typeof([])); //object console.log(typeof(fun)); //function 通过面的代码示例，你会发现当用typeof检测引用类型时都会显示object 当我们想知道变量到底是什么类型的对象时，ECMAStript提供了instanceof操作符 //语法如下： result = variable instanceof constructor //意为 变量variable是构造函数constructor的实例 使用instanceof检测引用类型，类型一定是对象类型，大小写要注意 console.log(person instanceof Object); //true console.log(arr instanceof Array); //true console.log(pattern instanceof RegExp);//true 若使用instanceof检测基本类型，则会返回false，因为基本类型不是对象 使用对象的constructor判断其构造函数 console.log(arr.constructor === Array); //true console.log(date.constructor === Date); //true console.log(fun.constructor === Function);//true 使用constructor检测对象类型时要注意：实现继承时，一定要将constructor属性手动更改，否则检测会出错 function parent(){} function child(){} child.prototype = new parent(); //child继承parent var obj = new child(); console.log(obj.constructor === child); //false console.log(obj.constructor === parent); //true 要避免这种情况，一定要在原型继承的时候，手动将原型的构造函数修改为本身 child.prototype.constructor = child; console.log(obj.constructor === child); //true console.log(obj.constructor === parent); //false 通用的方法，但不能检测自定义类型 Object.prototype.toString.call(variable); //返回类似[object String],[object Array]等形式来直接判断类型，一般情况用typeof就够了 JavaScript基本数据类型JavaScript有五种基本数据类型：undefined，Null，Boolean，Number和String Undefined类型： Undefined类型只有一个值，即特殊值undefined 在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined 是定义了但尚未初始化其值，不等同于未定义的变量 但是用typeof检测时两者都为undefined Null类型： Null类型也是只有一个值，即特殊值null 从逻辑上null值表示一个空对象指针，所以typeof检测null返回‘object’ 如果定义的变量准备用来保存对象，那么最好将该变量初始化为null而不是其他值 Boolean类型： Boolean类型有两个值true和false 要将一个值转换为其对应的Boolean值，可以直接调用转型函数Boolean() | 数据类型 | 转换为true的值 | 转换为false的值 || ——– | —–: | :—-: || Boolean | true | false || String | 任何非空字符串 | “”(空字符串) || Number | 任何非零数字值 | 0和NaN || Object | 任何对象 | null || Undefined | 不适用 | undefined | 流控制语句（如if）将自定执行相应的Boolean转换 Number类型： Number类型的数字值包括整数和浮点数 浮点数值中必须包含一个小数点，并且小数点后面必须至少一位有效数字 数值范围限制在Number.MAX_VALUE ~ Number.MIN_VALUE之间 还有一个特殊值NaN，用于表示一个本来要返回数值的操作符未返回数值的情况（这样就不会抛出错误了），比如任何数值除以0会导致错误，在其他语言中会停止代码执行。但是在ECMAScript中，返回NaN，但不会影响一塔代码执行。 String类型: 用双引号或者单引号表示 一旦被创建，他们的值就不能改变，除非通过销毁原来的字符串，然后用另一个包含新值得字符串填充该变量 var lang = &quot;Java&quot;; lang = lang + &quot;Script&quot;; //以上两行代码执行过程如下：首先创建一个能容纳10个字符串的新字符串，然后在这个字符串中填充“Java”和“Script”，最后销毁原来的字符串“Java”和“Script”，因为这两个字符串没有任何用了，当然这个过程是在后台发生的。 将一个值转换为字符串有两种方式： 第一种是调用toString()方法，但是null和undefined没有这个方法； 第二种是使用转型函数String()，转换规则如下： 如果值有toString()方法，则调用该方法 如果值是null，则返回“null” 如果值是undefined，则返回“undefined” JavaScript复杂数据类型（引用类型）JavaScript有Object，Array，Date，RegExp，Function，基本包装类型等复杂数据类型 Object类型： Object其实是一组数据和功能的集合。 对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。 var person = new Object(); person.name = &quot;annie&quot;; person.age = 22; 对象字面量表示法 var person = { name : &quot;annie&quot;, age : 22 } //使用以上字面量法，读取属性值时只能以person.name读 var anotherperson = { &quot;name&quot; : &quot;annie&quot;, &quot;age&quot; : 22 } //使用第二种字面量法，读取属性值既可以用anotherperson.name读取，也可以使用下标法anotherperson[&quot;name&quot;]来读取 var anothertwoperson = { &quot;first name&quot; : &quot;annie&quot;, &quot;age&quot; : 22 } //不能使用点表示法来访问，这时方括号表示法就有很好的用处了 Array类型 数组的大小可动态调整 数组的数据类型可不同，即第一项是字符串，第二项是数值，第三项是对象等等 可以用new操作符，也可以省去new操作符，或者直接用数组字面量表示法 栈方法： push() 添加到数组尾部 pop() 从数组末尾移除最后一项 队列方法： push() 添加到数组尾部 shift() 从数组前端移除第一个项 反向队列方法： unshift() 添加到数组前端 pop() 从数组末尾移除最后一项 重排序方法： reverse() 反转数组 sort() 按照升序排列数组项(先针对每项调用toString()方法，比较得到的字符串) 若不想按照默认比较字符串法来排序，课传入一个比较函数，例如：传入以下比较函数，则会按照升序排序 function compare (value1,value2){ //第一个参数小于第二个参数，应该排在第二个参数前面，所以返回-1 //第一个参数大于第二个参数，应该排在第二个参数后面，所以返回1 //两个参数相等，则返回0 if(value1 &lt; value2){ return -1; } else if(value1 &gt; value2){ return 1; } else { return 0; } } 操作方法： concat() 基于当前数组的所有项创建一个新数组，先创建一个当前数组的副本，再将接受到的参数添加到该副本的末尾，最后返回新构建的数组 slice() 基于当前数组的一个或者多个项创建一个新数组 接收一个参数，则返回从该指定位置到数组末尾位置的所有项、 接收两个参数，则返回从该指定位置到结束位置但不包括结束位置的所有项 splice() 有三个个参数： splice(起始位置，要删除的项数，要插入的项) 删除：指定起始位置，和要删除的项 插入：指定起始位置，要删除的项数：0，要插入的项 替换：指定起始位置，要删除的项数，要插入的项 位置方法： indexof() 从数组的开头开始向后查找第一个值为参数的索引 lastIndexof() 从数组的末尾开始查找第一个值为参数的索引 迭代方法： every() 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true filter() 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组 forEach() 对数组中的每一项运行给定函数，这个方法没有返回值 map() 对数组中的每一项运行给定函数，返回每项函数调用的结果组成的数组 some() 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true 归并方法： reduce() 从数组的第一项开始，逐个遍历到最后 reduceRight() 从数组的最后一项开始，向前遍历到第一项 以上两个方法均接收一个函数，并带有四个参数，分别是前一个值，当前值，项的索引，数组对象 Date类型： RegExp类型： var expression = / pattern / flags； 由一个模式和一个或者多个标志构成 g：表示全局模式 i：表示不区分大小写模式 m：表示多行模式 Function类型： 在使用new Function(arg1,arg2,arg3,…,sentence)创建函数时，最后一个参数被解析为函数体，其余均被解析为参数 每个函数都是Function类型的实例 没有重载 解析器在向执行环境中加载数据时，对于函数声明和函数表达式并非一视同仁 解析器会率先读取函数声明，并使其在执行任何代码之前可用 至于函数表达式，则必须等到解析器执行到他所在的代码行，才会被解释执行 alert(sum(10,10)) function sum(num1,num2){ return num1+num2; } alert(sum(10,10))//报错 var sum = function(num1,num2){ return num1+num2; } 函数内部属性 函数内部有两个特殊的对象：arguments和this arguments主要用来保存函数参数，但这个对象还有一个名叫callee的属性，是一个指向拥有这个arguments对象的函数的指针 ES5规范了另一个函数对象的属性：caller，保存着调用当前函数的引用 length：函数希望接收的命名参数的个数 prototype：保存它们所有实例方法的真正所在 apply() apply(函数执行的作用域,arguments) call() call(函数执行的作用域,arguments[0],arguments[2],…) 基本包装类型： 实际上，读取一个基本类型时，后台就会自动创建一个基本包装类型的对象 var s1 = &quot;some text&quot;; var s2 = s1.substring(2); //从逻辑上讲，基本类型值不是对象，不应该有方法 //实际上，读取s1时，后台会自动完成以下处理 1.创建String类型的一个实例 2.在实例上调用指定的方法 3.销毁这个实例 //所以基本包装类型是不能添加属性的，因为在执行瞬间后立即销毁 单体内置对象 Global对象：全局属性和方法都是属于Global对象的 Math对象： JavaScript中运算符优先级JavaScript事件委托事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件，只需在DOM树中尽量最高的层次上添加一个事件处理程序，事件委托不仅可以使代码简洁整齐，同时也可以减少内存占用，提高效率，例子如下： &lt;ul id=&quot;myLinks&quot;&gt; &lt;li id=&quot;goSomewhere&quot;&gt;Go somewhere&lt;/li&gt; &lt;li id=&quot;doSomething&quot;&gt;Do something&lt;/li&gt; &lt;li id=&quot;sayHi&quot;&gt;Say hi&lt;/li&gt; &lt;/ul&gt; var list = document.getElementById(&quot;myLinks&quot;); EventUtil.addHandler(list, &quot;click&quot;, function(event){ event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch(target.id){ case &quot;doSomething&quot;: document.title = &quot;I changed the document&apos;s title&quot;; break; case &quot;goSomewhere&quot;: location.href = &quot;http://www.wrox.com&quot;; break; case &quot;sayHi&quot;: 9 alert(&quot;hi&quot;); break; } }); 使用实例：jQuery中 bind()方法：直接绑定在元素上，或者是多个事件处理程序，也可以传入需要的参数 live()方法：通过冒泡的方式绑定到元素上，绑定到documentDOM节点上，之所以能都给未来元素添加事件处理程序，就是因为绑定到了document DOM节点上的缘故，只有一次事件绑定，不同于bind方法，给所有元素挨个绑定 delegate()方法：绑定事件处理程序到指定事件代理父容器，缩小了范围的事件代理 on()方法：实际上是整合了前三种的一种新事件绑定机制 JavaScript事件流事件流描述的是从页面中接收事件的顺序 事件冒泡：IE的事件流叫作事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较不具体的节点（document对象）事件捕获：Netscape提出另一种事件流叫做事件捕获，即事件熊不太具体的节点（document对象）沿着DOM树依次向下，一直传播到事件的实际目标（具体的节点）DOM事件流：包括事件捕获阶段，处于目标阶段，和事件冒泡阶段JavaScript中Global对象，window对象，document对象的区别 Global对象是JavaScript运行时所在的宿主环境提供的全局对象，是一个Object。最常见的宿主环境是浏览器和nodejs，它只是一个抽象的概念。 window对象就是浏览器引擎对Global对象的封装 Document对象：每个被浏览器载入的HTML文档都会成为Document对象，而Document对象，是window对象的一部分，可以直接通过document访问，也可通过window.document属性进行访问 JavaScript中的this 首先，this是JavaScript中的一个关键字 它是在函数运行时，自动生成的一个内部对象，只能在函数内部使用 根据函数的使用场景不同，this的值也会发生变化 但总的原则是：this始终指向调用函数的那个对象 情况一：纯粹的函数调用这是函数的最通常用法，属于全局性调用，此时的this就指代全局对象Global对象； function test(){ this.x = 1; alert(this.x); } test();//1 ### var x = 1;//此时的x是全局对象Global的属性 function test(){ alert(this.x); } test();//1；所以全局环境下this指代Global对象 ### var x = 1; function test(){ this.x = 0; //改变全局属性x的值 } test(); alert(x);//0 所以在全局环境运行的函数，相当于是全局对象的属性，即这种函数执行时相当于是Global对象调用的，所以this指代全局对象Global。 情况二：作为对象方法的调用函数作为某个函数的方法调用时，这时的this指代这个对象。 function test(){ alert(this.x); } var o = {}; o.x = 1; o.fun = test; o.fun();//1 此时对象o的方法指向test函数，这时的this就指代调用此方法的对象 情况三：作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象，这时的this将会指向这个新对象。 function test(){ this.x = 1; } var o = new test(); alert(o.x); //1 ### var x = 2; function test(){ this.x = 1; } var o = new test(); alert(x);//2 若this是Global对象的话，x将会在创建o对象的时候改变成1，所以作为构造函数调用时，this指向新对象。 情况四：apply调用apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象，所以此时的this指代第一个参数。 var x = 0; function test (){ alert(this.x) } var obj = {}; obj.x = 1; obj.fun = test; obj.fun.apply();//0 obj.fun.apply(obj);//1 obj.fun.apply(this);//0 apply()的参数为空的时候，默认调用全局对象，所以此时this指代全局对象。若传入o作为执行函数的作用域，则this指代o。需要区别的是最后一个传入this作为函数的执行作用域时，因为是在全局环境调用的，所以此时this指代Global，x仍为全局对象属性x的值，即为0。 JavaScript中的new一般看到new会想到生成一个实例对象，但在JavaScript中new存在的意义更多是实现JavaScript中的继承机制 先看一个new创建对象的例子： function Person(type,name){ this.type = type; this.name = name; } Person.race = &quot;People&quot;; Person.prototype.say = function(){ console.log(&quot;I&apos;m a &quot; + this.type + &quot;,my name is &quot; + this.name); } var student1 = new Person(&quot;student&quot;,&quot;annie&quot;); console.log(student1.type,student1.name,student1.race);//student,annie,undefined student1.say();//I&apos;m a student,my name is annie console.log(Person.name,Person.race);//Person,People Person.say();//Person.say not a function new 的执行机制 new Person(&quot;student&quot;,&quot;annie&quot;) = { var obj = {}; obj._proto_ = Person.prototype; //这里可以结合this来理解，在obj对象的执行环境调用Person函数并传入参数&quot;student&quot;和&quot;annie&quot;,Person.call 传入了执行作用域obj，则this指向obj,所以obj.type = &quot;student&quot;,obj.name = &quot;annie&quot; var result = Person.call(obj,&quot;student&quot;,&quot;annie&quot;); return typeof result === &quot;object&quot; ? result : obj; } 证明student1是Person的实例： student1 instanceof Person;//true instanceof的执行规则是： var L = A._proto_; var R = B.prototype; if(L===R) return true; 则证明A是B的实例，在生成student1时，student1.proto确实被赋值为Person.prototype JavaScript继承机制的设计思想继承的关键是一个对象可以调用另一个对象的属性方法。 首先，按照传统面向对象语言的对象实例生成的方法 比如Java： class Person { public void eat(){ System.out.println(&quot;person eat&quot;); } } public class Student extends Person{ } //此时子类Student将继承父类Person的eat()方法 而JavaScript为了不增加入门难度，没有引入类的概念，而是直接通过new+构造函数来生成一个对象的实例，但是直接从构造函数生成实例对象不能满足属性方法共享的这种机制，比如： function Person (name){ this.name = name; this.type = &quot;person&quot;;//假设此时想设计type为对象的共享属性 } var person1 = new Person(&quot;bbn&quot;); var person2 = new Person(&quot;mk&quot;); person1.type = &quot;student&quot;; alert(person2.type);//person，无法共享数据，浪费了资源 所以引入了原型prototype：JavaScript在设计的时候，为构造函数设计了一个prototype属性，专门用来存放共享属性和方法，不需要共享的则直接放在构造函数里。使用构造函数new一个实例对象的同时将自动引用这个构造函数的prototype对象的属性和方法。从而实现对象的继承： function Person(name){ this.name = name;//这个属性将是每个实例对象独立的属性，相互不受影响 } Person.prototype = {type:&quot;person&quot;};//原型对象中存放共享属性和方法 var person1 = new Person(&quot;bbn&quot;); var person2 = new Person(&quot;mk&quot;); //要修改type只能通过构造函数的原型对象进行修改 Person.prototype.type = &quot;student&quot;; alert(person2.type);//student JavaScript创建对象工厂模式 function createPerson(name, age, job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){ alert(this.name); }; return o; } 构造函数模式 function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.sayName = function(){ alert(this.name); }; } 原型模式：所以都添加到原型中 function Person(){ } Person.prototype.name = &quot;Nicholas&quot;; Person.prototype.age = 29; Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function(){ alert(this.name); }; 组合使用构造函数和原型模式 function Person(name, age, job){ this.name = name; 3 this.age = age; this.job = job; this.friends = [&quot;Shelby&quot;, &quot;Court&quot;]; } Person.prototype = { constructor : Person, sayName : function(){ alert(this.name); } } 动态原型模式 function Person(name, age, job){ this.name = name; this.age = age; this.job = job; // if (typeof this.sayName != &quot;function&quot;){ Person.prototype.sayName = function(){ alert(this.name); }; } } JavaScript的继承实现JavaScript对对象的封装一、最原始的生成对象模式创建一个对象，给它添加属性和方法 var student = {}; student.name = &quot;annie&quot;; student.study = function (){ //study } 二、原始模式改进封装一个具有返回值对象的函数，解决代码重复的问题 function student(name){ return { name:name } } 三、构造函数模式构造函数使用this变量，在使用new生成实例的时候，this将会指向这个新的实例对象 function student(name){ this.name = name; } //这样生成的实例对象将会有有一个constructor属性值都为student，表示student为他们的构造函数 四、prototype模式即将需要共享的属性和方法添加到构造函数的原型中 JavaScript中构造函数的继承思考，如何让student继承Person的属性： function Person(){ this.species = &quot;People&quot;; } function student(name){ this.name = name; this.type = &quot;student&quot;; } 一、构造函数绑定使用call或者apply将父对象的构造函数绑定在子对象上 function student(name){ //添加这一行，实际上当new创建一个新的对象时，相当于是在新对象的执行环境内执行this.species=&quot;People&quot;，所以student将会继承Person的属性 Person.apply(this,arguments); this.name = name; this.type = &quot;student&quot;; } 二、prototype模式所以共享的属性和方法设置在构造函数的prototype属性中 student.prototype = new Person();//加了这一句后，student.prototype.constructor = Person，所以需要手动纠正 student.prototype.constructor = student; 三、直接继承prototype待补充。。。 JavaScript实现浅拷贝和深拷贝浅拷贝实现： function extendCopy(p){ var c = {}; for(var i in p){ c[i] = p[i]; } c.uber = p; return c; } 深拷贝就是实现真正意义上的数组和对象的拷贝，其实就是递归浅拷贝： function deepCopy(p,c){ var c = c || {}; for(var i in p){ if(typeof(p[i]) === &apos;object){ c[i] = (p[i].contructor === Array) ? [] : {}; deepCopy(p[i],c[i]); } else { c[i] = p[i]; } } return c; } XMLHttpRequest对象深入理解 AJAX = Asynchronous JavaScript and XML (异步的JavaScript和XML) 而XMLHttpRequest对象是AJAX的基础。用于在后台与服务器交换数据 创建XMLHttpRequest对象 var xhr = new XMLHttpRequest(); var xhr = new ActiveXObject(“Mircosoft.XMLHTTP”);//针对IE5、6 向服务器发送请求 xhr.open(“GET”,”url”,true);//true则异步发送请求，false则同步发送请求 xhr.send(); get请求和post请求 get请求：最常见的请求类型，速度更快，更简单，可传少量经过正确编码的参数 post请求：通常用于给服务器发送应该被保存的数据，post可以包含很多数据，且不受格式的限制，参数通过send方法来传递 HTTP头部信息 默认情况下，在发送XHR请求的同时，还会发送下列头部信息 Accept：浏览器能够处理的内容信息 Accept-Encoding：刘安琪能都处理的压缩编码 Accept-Charset：浏览器能够显示的字符集 Accept—Language：浏览器当前设置的语言 Connection：浏览器与服务器之间的连接类型 Cookie：当前页面设置的任何Cookie Host：发出请求的页面所在的域 Referer：发送请求的页面的URL User-Agent：浏览器的用户代理字符串 请求头部信息可以使用setRequestHeader方法来设置，此方法放在open之后send之前 getAllResponseHeaders()方法可以取得所有响应头部信息 xhr对象在响应后自动填充响应数据 responseText：作为响应主体被返回的文本 responseXML：如果响应的内容类型是“text/xml”或者“application/xml”,这个属性中将保存包含着响应数据的XML DOM文档 status：响应的HTTP状态 statusText：HTTP状态说明 onreadystatechange事件 每当readyState改变时都会触发onreadystatechange事件 readyState 0：请求未初始化 1：服务器连接已建立（说明已经调用了open方法） 2：请求已接收（已经调用了send方法） 3：请求处理中（已经开始接受响应的数据） 4：请求已完成，且响应就绪（已经接收到全部数据） status 200：OK 404：未找到页面 原生JavaScript实现ajax请求var xhr; function createXMLHttpRequest(){ if(XMLHttpRequest){ xhr = new XMLHttpRequest(); } else if(window.ActiveXObject){ xhr = new ActiveXObject(&quot;MircoSoft.XMLHTTP&quot;); } } function sendAjax(){ createXMLHttpRequest(); xhr.open(&quot;GET&quot;,&quot;url&quot;,true); xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xhr.onreadystatechange = callback; xhr.send(); } function callback(){ if(xhr.readyState == 4){ if(xhr.status == 200){ var result = xhr.responseText; //... } } } 跨域的实现方式首先理解为什么需要跨域编程，因为JavaScript有同源策略的限制，所以先来看同源策略是什么 域名baidu.com：形式的是一级或者顶级域名www.baidu.com：形式的是二级域名，即www只是一个主机名 同源策略假设任何人在任何情况下都可以随意对一个网页进行修改，那么网站将会不安全，所以当时Netscape公司给浏览器引入了同源策略，浏览器之所以能安全应用到现在，就是同源策略的应用 引入同源策略的目的：为了保证用户的信息安全，防止恶意的网站窃取数据所谓同源指的是 协议相同 域名相同 端口相同 即除非A和B网页同源，否则A网页设置的Cookie，B网页不能打开 举例说明：http://www.baidu.com/dir/page.html这个网址，它的协议是http://，域名是www.baidu.com，端口默认为80，它的同源情况： http://www.baidu.com/dir2/otherpage.html：同源，因为协议，域名和端口均相同 http://baidu.com/dir/otherpage.html：不同源（域名不同） http://v.www.baidu.com/dir/otherpage/.html：不同源（域名不同） http://www.baidu.com:81/dir/otherpagel.html：不同源（端口不同） https://www.baidu.com/dir/hhh.html：不同源（协议不同） 目前非同源时，共有三种行为受到限制 cookie、localstorage和indexDB无法读取 DOM无法获得 ajax请求不能发送 cookie跨域规避方式 每个cookie都是一个名/值对，要一次性存储多个cookie需要用分号隔开。 如果值中不可避免的使用；，=以及空格，则需要用escape函数进行编码，读取时用unescape来解码 可设置有效时间，用expires字段保存，所以若要删除一个cookie将其expires字段设置为一个过去的时间即可，若不设定过期时间，即当浏览器关闭时cookie自动消失。 指定可访问cookie的主机名： 例如www.google.com和gmail.google.com就是同一域google.com下的两个不同主机名 而不同主机的cookie不能相互访问 但可以通过domain参数来实现对其的控制 document.cookie = “name=value;domain=.google.com”，这样所有google.com下的主机都可以访问该cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享 为了规避这种限制，又引入了一种机制，当两个网页一级域名相同，只是二级域名不同时，浏览器允许通过document.domain共享cookie 举例说明：A网页时http://w1.example.com/a.html，B网页时http://w2.example.com/b.html,设置document.domain = “example.com” 在A网页中通过脚本设置一个cookie，document.cookie = “test=hello”; B网页中就可以读取，var allcookies = document.cookie 或者直接通过服务器设置cookie，指定cookie所属的域名为一级域名，则二级域名和三级域名不用设置即可读取这个歌cookie Set-Cookie: key=value;domain=.example.com;path=/ 但是此种共享只适用于cookie和iframe窗口，localStorage和indexDB无法通过这种方法 iframe实现跨域的三种方式iframe窗口和父窗口不是同源的话，不能取得对方的DOM。 即： //父窗口执行 document.getElementById(&quot;myIFrame&quot;).contentWindow.document //自窗口执行 window.parent.document.body 以上两种形式均会报错 解决方式： 若两个窗口一级域名相同，只是二级域名不同，那么通过document.domain属性，就可以规避同源政策，拿到DOM 若两个完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。 片段识别符（fragment identifier） window.name 跨文档通信API(Cross-document messaging) 一、片段标识符指的是网页URL#后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。 父窗口将信息写入子窗口的片段标识符中 var iframe = document.getElementById(&quot;myIFrame&quot;); var src = iframe.src + &quot;#&quot; + sharedata; iframe.src = src; 子窗口就可以通过监听hashchange事件得到通知。 window.onhashchange = checkmessage; function checkmessage (){ var message = window.location.hash; } 子窗口也可改变父窗口的片段标识符 parent.location.href = target + &quot;#&quot; + hash; 二、window.namewindow的name属性无论同源与否，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页就可以读取它。 父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性中 window.name = sharedata; 子窗口跳回一个与父窗口同域的网址 location = &quot;http://parent.com/xxx.html&quot;; 此时主窗口就可以读取子窗口的window.name了。 var getdata = document.getElementById(&apos;myFrame&apos;).contentWindow.name; 由于window.name容量很大，可以放置非常长的字符串，但是 缺点是：父窗口必须监听子窗口的window.name的变化，会影响页面的性能。 三、window.postMessageHTML5引入了一个全新的API：跨文档通信API，叫作Cross-document messaging。这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，无论同源与否。 举例来说： 父窗口嵌入子窗口： &lt;iframe src = &quot;http://bbb.com:8080/otherpage.html&quot; id = &quot;otherpage&quot;&gt;&lt;/iframe&gt; 父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以 var popup = document.getElementById(&apos;otherpage&apos;).contentWindow; popup.postMessage(&apos;hello world&apos;,&apos;http://bbb.com&apos;); postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源，即 协议+域名+端口，也可设置为*，表示不限制域名，向所有窗口发送。 子窗口向父窗口发送消息的写法类似。 window.opener.postMessage(&quot;Nice to see you&quot;,&quot;http://aaa.com&quot;); 父子窗口都可以通过message事件，监听对方的消息。 window.addEventListener(&apos;message&apos;,function(e){ console.log(e.data); //这里需要回复消息的话，可以直接用event.source来回复 event.source.postMessage(&apos;message have recevied&apos;,&quot;*&quot;); }) message事件的事件对象event，提供一下三个属性 event.source：发送消息的窗口//可直接回复消息 event.origin：消息发向的网址//过滤不是给本窗口发送的消息，比如有些不限制域名向所有窗口发送的消息，如果接收则会浪费资源 event.data：接收到的消息内容 event.origin属性的用法： window.addEventListener(&apos;message&apos;,recevieMessage); function recevieMessage(event){ if(event.origin !== &apos;http://aaa.com&apos;) return; ... } 四、LocalStorage通过window.postMessage，可相互读写localStorage 跨域AJAX请求不能发送规避方式同源政策规定，AJAX请求只能发给同源的网址，否则就报错。 除了服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。 JSONP WebSocket CORS 一、JSONP (JSON with padding)JSONP是服务器与客户端跨源通信的常用方法。因为同源策略不阻止动态脚本插入，动态插入的脚本会被当做是当前域上加载的。 function addScriptTag(src) { var script = document.createElement(&apos;script&apos;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script); } window.onload = function () { addScriptTag(&apos;http://example.com/ip?callback=foo&apos;); } function foo(data) { console.log(&apos;Your public IP address is: &apos; + data.ip); }; 服务器example.com收到请求后，会将请求的ip值放在指定的callback回调函数foo中放回，如下： foo({ &quot;ip&quot; : &quot;8.8.8.8&quot; }) §而由于&lt;script&gt;元素请求的脚本会直接作为代码运行。这时，所以返回的这段代码将会直接运行。 二、websocketwebsocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源策略，只要服务器支持就可以跨域通信。 websocket请求的头信息： GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Origin: http://example.com 请求头信息有个origin，就是该请求的请求源，即该请求发自哪个域名，服务器可以通过这个字段来判断时候允许这次通信，若是该域在白名单中，服务器就会响应 HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk= Sec-WebSocket-Protocol: chat 三、CORSCORS是w3c标准，全称是“跨域资源共享”（Cross-origin resource sharing）。 待补充。。。。 跨域的使用场景一、前端跨域方式： image.src、style.href无法获取服务器的数据返回，适合发送数据但不需要得到返回数据，比如向服务器发送错误信息 script.src和服务器端配合可以得到数据返回 postMessage，window.name，document.domain是两个窗口相互传递 postMessage需要IE8+,firefox,chrome,safari,opera支持 window.name限制大小2M，但所有浏览器支持 document.domain必须跨域双方的顶级域名相同 二、前后端结合jsonp 三、纯后端 CORS：是w3c标准的方式，通过web服务器端设置，响应Access-Control-Alow-Origin来指定白名单 服务器代理，通过服务器转发请求 JavaScript闭包一、变量的作用域要理解闭包，首先要理解JavaScript的作用域：全局和局部。 函数内部可以读取全局变量，但是函数外部无法读取函数内部的局部作用域。 二、从外部读取局部变量将内部函数作为返回值，就可以在outter函数外部读取其内部变量值了 function outter (){ var n = 999; function inner (){ alert(n); } return n; } var result = outter(); result();//999 三、闭包的概念我理解为：闭包就是能够读取其他函数内部变量的函数，但是本质上，闭包就是连接函数内部和外部的一座桥梁 四、闭包的用途 可以读取函数内部的变量 让这些变量值始终保存在内存中 function f1(){ var n=999; nAdd=function(){n+=1} function f2(){ alert(n); } return f2; } var result=f1(); result(); // 999 nAdd(); result(); // 1000 说明函数f1中的局部变量n一直保存在内存中，并没有在f1调用后自动清除，因为内部函数f2被赋值给了一个全局变量，导致f2一直在内存中，而f2存在依赖于f1，所以f1也始终在内存中，而不是在调用结束后没被来及回收机制回收。 五、闭包的注意事项 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，解决方法是，在退出函数之前，将不适用的局部变量全部删除。 闭包在父函数外部可以改变父函数内部变量的值，不要随便改变父函数内部变量的值 JavaScript数组去重Array.prototype.unique1 = function() { var n = []; //一个新的临时数组 for(var i = 0; i &lt; this.length; i++) //遍历当前数组 { //如果当前数组的第i已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if (n.indexOf(this[i]) == -1) n.push(this[i]); } return n; } ### Array.prototype.unique3 = function() { var n = [this[0]]; //结果数组 for(var i = 1; i &lt; this.length; i++) //从第二项开始遍历 { //如果当前数组的第i项在当前数组中第一次出现的位置不是i， //那么表示第i项是重复的，忽略掉。否则存入结果数组 if (this.indexOf(this[i]) == i) n.push(this[i]); } return n; } ### Array.prototype.unique4 = function() { this.sort(); var re=[this[0]]; for(var i = 1; i &lt; this.length; i++) { if( this[i] !== re[re.length-1]) { re.push(this[i]); } } return re; } JavaScript参数传递JavaScript中的参数传递和其他的计算机语言有所不同，定义的函数只接收两个参数，你也可以传递一个或者三个甚至不传参数，原因是： 因为在ECMAScript中参数在内部是用一个数组来表示的，函数接收到的始终是这个数组，并不关心这个数组内部是否有元素 也可以直接使用arguments对象来访问参数 传递参数的方式JavaScript中所有的函数的参数都是按值传递的 基本类型 function addTen(num){ num += 10; return num; } var count = 20; var result = addTen(count); //count被传入函数时，只是将count的值赋给num这个局部变量， alert(count); //20 alert(result); //30 引用类型 有很多人会在引用类型当做参数被传递时感到疑惑，例如： function setName(obj){ obj.name = &quot;localname&quot;; } var person = new Object(); setName(person); alert(person.name); //localname 在函数内部改变obj的name反映到了全局作用域中的对象person中了，看起来像是参数按照引用传递的，接下来看下面的代码： function setName(obj){ obj.name = &quot;localname&quot;; obj = new Object(); obj.name = &quot;changename&quot;; } var person = new Object(); setName(person); alert(person.name); //localname 假设是按引用传递的参数，那person的name应该是changename才对 事实上： 当person当做参数传递给setName函数时，setName作用域内的局部变量obj对象会指向person对象 第一次obj.name被赋值localname时，实际上是person对象的name属性被赋值为localname，当obj指向一个新对象后，和person再就没有关系了 所以当第二次obj.name被赋值changename时，person不会受到任何影响 JavaScript中错误类型SyntaxError（语法错误）解析代码时发生的语法错误 eg:var 1a; Uncaught SyntaxError: Unexpected number ReferenceError（引用错误）a.引用了一个不存在的变量 eg:console.log(a); Uncaught ReferenceError: a is not defined b.将变量赋值给一个无法被赋值的对象 eg:console.log()=1; Uncaught ReferenceError:Invalid left-hand side in assignment RangeError(范围错误)超出有效范围 TypeError（类型错误）a.变量或参数不是预期类型，比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数 eg: var a= new 123; Uncaught TypeError: 123 is not a function b.调用对象不存在的方法 eg:var a;a.aa(); Uncaught TypeError: Cannot read property &apos;aa&apos; of undefined URLError（URL错误）EvalError（eval错误）eval函数没有被正确执行 JavaScript的异常捕获机制基本的try…catch语句语法如下： try{ //可能发生异常的代码 }catch(error){ //发生错误执行的代码 } 实例： try{ console.log(b); console.log(&quot;我不会输出的，不要找了&quot;) }catch(error){ console.log(&quot;发生错误了&quot;) } console.log(&quot;我try catch后面的代码&quot;) 把有可能出问题的代码放在try语句中，try语句中理论上可以写任何代码，只要有一行代码出现问题，整个程序的执行流程就会立即调到catch语句中执行。 一旦try中有一行代码发生异常，则这行出错代码的后面的try中的其他语句都不会再执行。比如上面代码中的console.log(b);这行代码会出错，则立即去执行catch中的代码。所以console.log(“我不会输出的，不要找了”)这行代码则不会再执行 在执行catch中的代码之前，js引擎会首先根据错误类型自动创建一个错误，并通过catch后面的参数传递到catch中。不同的浏览器创建的error对象不一样，但是同创他们都包含一个message属性，值是这个错误的一些信息。 catch中的代码执行完毕之后，会继续执行后面的代码，程序不会停止下来。 根据不同错误类型分别处理try { someFunction(); } catch (error){ if (error instanceof TypeError){ //处理ૌ类型错误 } else if (error instanceof ReferenceError){ //处理引用错误 } else { //处理其他的错误 } } Error类型是基本的错误类型，其他类型都继承自这个类型。 EvalError 类型的错误会在使用 eval()函数而发生异常时被抛出 TypeError 类型在 JavaScript 中会经常用到，在变量中保存着意外的类型时，或者在访问不存在的 方法时，都会导致这种错误 一般情况，不同的错误，处理方式不一样。可以参考下面的处理方式。不过在实际开发中，很多程序员并没有形成处理错误的习惯。 throw主动抛出异常抛出JavaScript内置错误类型的对象function foo(num) { if(typeof num == &quot;number&quot;){ return num * num; }else{ throw new TypeError(&quot;类型错误，你应该传入一个数字...&quot;) } } console.log(foo(33)) console.log(foo(&quot;abc&quot;)) throw后面就是我们要抛出的异常对象。在以前的时候都是出现错误的时候浏览器抛出异常对象，只是现在是我们自己主动抛出的异常对象。 只要有异常对象抛出，不管是浏览器抛出的，还是代码主动抛出，都会让程序停止执行。如果想让程序继续执行，则有也可以用try…catch来捕获。 每一个错误类型都可以传入一个参数，表示实际的错误信息。 我们可以在适当的时候抛出任何我们想抛出的异常类型。throw new SyntaxError(“语法错误…”); 抛出自定义类型的错误对象我们不仅仅可以抛出js内置的错误类型的对象，也可以自定义错误类型，然后抛出自定义错误类型的对象。 ​如果要自定义错误类型，只需要继承任何一个自定义错误类型都可以。一般直接继承Error即可。 function MyError(message) { this.message = &quot;注意：这是自定义的错误&quot; this.name = &quot;自定义错误&quot;; } MyError.prototype = new Error(); try { throw new MyError(&quot;注意：这是自定义错误类型&quot;) }catch (error){ console.log(error.message) } console.log(&quot;这里会不会执行&quot;) 关于前端网络部分知识http协议相关问题常见的http状态码1字头-消息这类型状态码代表请求已被接受，需要继续处理。 100 continue 客户端应当继续发送请求 101 switching protocols 102 2字头-消息这类型状态码代表请求已成功被服务器接收、理解、并接受 200 OK 请求已成功 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立 202 Accepted 服务器已接受请求，但尚未处理 203 Non-Authoritative Information http请求头 http响应头","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://aiyuzhou.github.io/tags/JavaScript/"}]},{"title":"chrome书签","slug":"chrome书签","date":"2017-04-13T01:43:26.000Z","updated":"2017-04-13T01:44:07.000Z","comments":true,"path":"2017/04/13/chrome书签/","link":"","permalink":"https://aiyuzhou.github.io/2017/04/13/chrome书签/","excerpt":"","text":"书签浏览器 浏览器的工作原理 react react：创建可维护、高性能的UI组件 如何使用ES6编写一个react模块，并且编译后发布到npm react-component-starter:reactjs component starter project 深入理解react、redux 一看激动的reactjs入门 关于react和angular的思考 react精髓之一 diff算法 react源码分析系列 – 不可思议的react diff csdn react源码分析系列 – 不可思议的react diff 知乎 webpack and gulp webpack与gulp的区别及实例搭建 彻底解决webpack打包慢的问题","categories":[],"tags":[{"name":"书签","slug":"书签","permalink":"https://aiyuzhou.github.io/tags/书签/"},{"name":"chrome","slug":"chrome","permalink":"https://aiyuzhou.github.io/tags/chrome/"}]},{"title":"websocket学习笔记","slug":"websocket学习笔记","date":"2017-04-13T01:42:24.000Z","updated":"2017-04-13T01:42:57.000Z","comments":true,"path":"2017/04/13/websocket学习笔记/","link":"","permalink":"https://aiyuzhou.github.io/2017/04/13/websocket学习笔记/","excerpt":"","text":"websocket机制websocket是HTML5一种新的协议，它实现了浏览器与服务器全双工通信，建立在TCP之上，与http一样，通过TCP来传输数据，但websocket和http不同的是： websocket是一种双向通信协议，在建立连接之后，websocket服务器和浏览器客户端都能主动的向对方发送或接收数据，就像socket一样； websocket需要类似TCP的客户端和服务器通过握手连接，连接成功后才能互相通信。 http请求响应交互图 websocket请求响应交互图 上图对比可以看出，相对于传统http每次请求-应答都需要客户端与服务器建立连接的模式，websocket是类似socket的TCP长连接的通讯模式，一旦websocket连接建立后，不需要客户端重新发起连接请求，直到客户端或者服务器端断掉连接。 websocket跨域websocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源策略，只要服务器支持就可以跨域通信。 websocket请求的头信息： GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Origin: http://example.com 请求头信息有个origin，就是该请求的请求源，即该请求发自哪个域名，服务器可以通过这个字段来判断时候允许这次通信，若是该域在白名单中，服务器就会响应 HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk= Sec-WebSocket-Protocol: chat ajax轮询原理ajax轮询的原理很简单，让浏览器隔个几秒就发送一下请求，询问服务器是否有新信息。 缺点：需要服务器有很快的处理速度和资源。 长连接采用的也是轮询，不同的是，客户端发起请求后，如果没有消息，就一直hold住连接不返回，直到有新消息要返回给客户端时才返回，而后客户端再次建立连接。 缺点：需要有很高的并发，也就是同时接待客户端的能力(因为一直hold住连接占用资源) websocket通讯原理 websocket是一种双向通信协议，在建立连接之后，websocket服务器和浏览器客户端都能主动的向对方发送或接收数据，就像socket一样； websocket需要类似TCP的客户端和服务器通过握手连接，连接成功后才能互相通信。 httphttp是一种无状态的面向连接的协议，基于TCP协议，有以下特点： 简单快速，因为http协议简单，使得http服务器的程序规模小，因而通信速度很快。 灵活：http允许传输任意类型的数据对象，只需在正在传输的请求的头部信息content-type加以标记即可。 无连接：即每次连接只处理一个请求 无状态：如果后续处理需要前面的信息，则必须重新传输。 http状态：状态码由三位数字组成，第一个数字定义了响应的类别，具有五种可能值： 1XX：指示信息–表示请求已接受、继续处理 2XX：成功–表示请求已被成功接收、理解、接受 3XX：重定向–要完成请求必须进行更一步的操作 4XX：客户端错误–请求有语法错误或者无法实现 5XX：服务器端错误–服务器未能实现合法的请求 常见状态码： 200 OK //客户端请求成功 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在 500 Internal Server Error //服务器发送了不可预期的错误 503 Server Unavailable //服务器当前不能出来客户端请求，一段时间后恢复正常 http1.1持久连接http1.1中增加了connection：keep-alive这个头部信息，为了改善每个http请求都需要打开一个tcp socket连接，并且使用一次之后就会断开这个tcp连接。 但是keepalive配置不当也会导致资源无效的占用，所以要正确的设置keep-alive timeout字段。 管道机制http1.1版本还引入了管道机制，即同一个TCP连接里面，客户端可以同时发送多个请求 举例：客户端需要请求两个资源在http1.0中，在同一个TCP连接中，先发送A请求，收到响应后再发送B请求。在http1.1中，同时发送A和B请求，服务器按照顺序，先处理A请求并回应，然后再处理B请求。 http的keep-alive和TCP的keep-alivehttp keep-alive与tcp keep-alive，不是同一回事，意图不一样。http keep-alive是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高socket的效率。而tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。tcp keep-alive保鲜定时器，支持三个系统内核配置参数： echo 1800 &gt; /proc/sys/net/ipv4/tcp_keepalive_time echo 15 &gt; /proc/sys/net/ipv4/tcp_keepalive_intvl echo 5 &gt; /proc/sys/net/ipv4/tcp_keepalive_probes keepalive是TCP保鲜定时器，当网络两端建立了TCP连接之后，闲置idle（双方没有任何数据流发送往来）了tcp_keepalive_time后，服务器内核就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 tcp_keepalive_intvl后再次尝试发送侦测包，直到收到对对方的ack,如果一直没有收到对方的ack,一共会尝试 tcp_keepalive_probes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试tcp_keepalive_probes,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。","categories":[],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://aiyuzhou.github.io/tags/websocket/"}]},{"title":"","slug":"xcode调试ionic项目","date":"2017-02-24T10:53:13.000Z","updated":"2017-02-28T07:40:18.000Z","comments":true,"path":"2017/02/24/xcode调试ionic项目/","link":"","permalink":"https://aiyuzhou.github.io/2017/02/24/xcode调试ionic项目/","excerpt":"","text":"ionic build ios出现Error：munger.add_config_changes is not a function原因可能是版本不匹配导致更新cordova：npm update -g cordova更新后：rm -r platforms &amp;&amp; rm -r plugins重新添加平台：ionic platform add ios重新build：inoic build ios发现build成功在使用onesignal-cordova-plugin时出现window.plugins.onsignal.init not a function 当使用node-sass时出现libsass bindings not found时 先根据提示reinstall node-sass npm uninstall node-sass npm install node-sass 若是仍然有错误，重装所有node-moudles rm -rf node-moudles npm install 若是仍然有错误，重新build node-sass npm rebuild node-sass 若是仍然有错误，则可能是gulp-sass的版本过低 npm uninstall --save-dev gulp-sass npm install --save-dev gulp-sass@2 gulp-sass是使用gulp构建项目时把sass编译成css的一个插件，当你使用node4.x及以上版本时，则会需求更高版本的gulp-sass","categories":[],"tags":[]},{"title":"粒子群优化算法学习笔记","slug":"粒子群优化算法学习笔记","date":"2017-02-17T07:40:49.000Z","updated":"2017-02-20T08:56:46.000Z","comments":true,"path":"2017/02/17/粒子群优化算法学习笔记/","link":"","permalink":"https://aiyuzhou.github.io/2017/02/17/粒子群优化算法学习笔记/","excerpt":"","text":"粒子群优化算法原理：从随机解出发，通过迭代寻找最优解，也通过适应度来评价解的品质。PSO是一种随机的、并行的优化算法。PSO算法优点： 不要求被优化函数具有可微、可导、连续等性质，收敛速度较快，算法简单，容易编程实现。 PSO算法缺点： 对于有多个局部极值点的函数，容易陷入到局部极值点中，得不到正确的结果。造成这种现象的原因有两种，其一是由于待优化函数的性质；其二是由于微粒群算法中微粒的多样性迅速消失，造成早熟收敛。这两个因素通常密不可分地纠缠在一起。 由于缺乏精密搜索方法的配合，PSO算法往往不能得到精确的结果。造成这种问题的原因是PSO算法并没有很充分地利用计算过程中获得的信息，在每一步迭代中，仅仅利用了群体最优和个体最优的信息。 PSO算法虽然提供了全局搜索的可能，但并不能保证收敛到全局最优点上。 PSO算法是一种启发式的仿生优化算法，当前还没有严格的理论基础，仅仅是通过对某种群体搜索现象的简化模拟而设计的，但并没有从原理上说明这种算法为什么有效，以及它适用的范围。 当前针对PSO算法开展的研究工作种类繁多，经归纳整理分为如下八个大类： 对PSO算法进行理论分析，试图理解其工作机理； 改变PSO算法的结构，试图获得性能更好的算法； 研究各种参数配置对PSO算法的影响； 研究各种拓扑结构对PSO算法的影响； 研究离散版本的PSO算法； 研究PSO算法的并行算法； 利用PSoriasis算法对多种情况下的优化问题进行求解； 将PSO算法应用到各个不同的工程领域。 对于如何采用计算机构建具有合作行为的群集人工生命系统的五项基本原则： 临近原则：群体应该能够执行简单的空间和时间运算 质量原则：群体应该能感受到周围环境中质量因素的变化，并对其产生响应。 反应多样性原则：群体不应将自己获取资源的途径限制在狭窄的范围之内 稳定性原则：群体不应随着环境的每一次变化而改变自己的行为模式 适应性原则：当改变行为模式带来的回报是值得的时候，群体应该改变其行为模式","categories":[],"tags":[{"name":"粒子群优化算法","slug":"粒子群优化算法","permalink":"https://aiyuzhou.github.io/tags/粒子群优化算法/"}]},{"title":"前端常见问题总结","slug":"前端常见问题总结","date":"2017-02-14T07:46:03.000Z","updated":"2017-02-14T07:46:03.000Z","comments":true,"path":"2017/02/14/前端常见问题总结/","link":"","permalink":"https://aiyuzhou.github.io/2017/02/14/前端常见问题总结/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"手机端以及微信内置浏览器关于H5的开发遇到的问题","slug":"手机端以及微信内置浏览器关于H5的开发遇到的问题","date":"2017-02-14T06:17:08.000Z","updated":"2017-02-15T06:10:17.000Z","comments":true,"path":"2017/02/14/手机端以及微信内置浏览器关于H5的开发遇到的问题/","link":"","permalink":"https://aiyuzhou.github.io/2017/02/14/手机端以及微信内置浏览器关于H5的开发遇到的问题/","excerpt":"","text":"最近在开发一个H5页面，H5嘛都在微信中浏览，所以就神奇的入了微信内置浏览器的坑。 其中有两页是两个视频，理想效果是在滑到那页时自动播放视频，最开始拿到的视频是mov格式，我知道本身H5就没有来支持这个格式，侥幸试了试，在我的手机上可以播放，但不能自动播放，强制点击后全屏播放，诶，我一查全是说iPhone上不能嵌入页面自动播放，找资料查到了iphone-inline-video.min.js，用法可以看这里iphone-inline-video，到这里看来mov格式在我手机上是可以的，结果测试其他iPhone6，6p等等等都不行，侥幸试试嘛，格式是肯定要换的。 所以写了以下： &apos;&lt;video src=&quot;img/movie.mp4&quot; preload=&quot;auto&quot; autoplay=&apos;autoplay&apos; loop=&apos;loop&apos;&gt;&lt;/video&gt;&apos; 提前加载，自动播放，循环播放嘛 然后打开浏览器，什么都没有，真的什么都没有啊。。这里要指明的问题是用任何模拟器调试（指chrome上各种模拟器，还有如果开发微信web所用的微信web开发者工具）都很有可能和真机调试结果不同，比如我在iPhoneSE上可以显示mp4格式，可是微信开发者工具上却是显示不了的，你可以试试加个控制条，会发现控制条在，视频却是没有的。 然后啊，我就去网上先找了个ogg格式的试试，唉，也不行啊。这次是微信web开发者工具上可以显示，手机上不行。 然后我试着在source里分别放mp4和ogg格式： &apos;&lt;video preload=&quot;auto&quot; autoplay=&apos;autoplay&apos; loop=&apos;loop&apos;&gt; &lt;source src=&quot;img/movie.ogg&quot; type=&quot;video/ogg&quot;&gt; &lt;source src=&quot;img/movie.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;/video&gt;&apos; 再测试，微信web开发工具显示ogg格式，手机微信上显示mp4格式（别问我怎么知道的，我的两个视频内容不一样哈哈哈 那我再换顺序 &apos;&lt;video preload=&quot;auto&quot; autoplay=&apos;autoplay&apos; loop=&apos;loop&apos;&gt; &lt;source src=&quot;img/movie.mp4&quot; type=&quot;video/ogg&quot;&gt; &lt;source src=&quot;img/movie.ogg&quot; type=&quot;video/mp4&quot;&gt; &lt;/video&gt;&apos; 结果没变，首先微信web不支持mp4格式，但支持ogg，然而手机微信却相反，首先要说的是，微信web开发者工具做的太烂。。既然你专门做了个开发者工具，就要和微信对应的上，省去开发者强行在微信内置浏览器调试的繁琐过程，真的非常非常繁琐啊。 那么微信内置浏览器到底支持什么格式呢？ 反正mp4是支持的。。ogg按照我这样测试过说明不支持，至于webM还没测试过呢 另外，ios不支持video自动播放，记得调用video.play()","categories":[],"tags":[{"name":"H5","slug":"H5","permalink":"https://aiyuzhou.github.io/tags/H5/"},{"name":"WeChat","slug":"WeChat","permalink":"https://aiyuzhou.github.io/tags/WeChat/"},{"name":"微信内置浏览器","slug":"微信内置浏览器","permalink":"https://aiyuzhou.github.io/tags/微信内置浏览器/"},{"name":"video","slug":"video","permalink":"https://aiyuzhou.github.io/tags/video/"}]},{"title":"canvas实现小球的弹性碰撞","slug":"bouncing1","date":"2016-12-16T10:02:37.000Z","updated":"2016-12-18T09:31:41.000Z","comments":true,"path":"2016/12/16/bouncing1/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/16/bouncing1/","excerpt":"","text":"写在最前面首先，代码源于supperjet源码: 小球碰撞运动效果图如下：写之前，想一个问题，如果我要写一个box内弹性碰撞的小球的动画，我应该从哪里入手。 先从对象开始考虑，我需要定义ball和box两个对象，ball需要有大小，颜色，所在位置这些属性，box只需要有长宽属性，而在动画中canvas就是box。 考虑碰撞规则 若碰撞到box的上边，则碰撞条件是：ball的中心点坐标 y 小于其自身半径 radius，解决方法是：将ball的中心点坐标 y 置为ball.radius并且ball的垂直运动方向反向 若碰撞到box的下边，则碰撞条件是：ball的中心点坐标 y 与其自身半径 radius之和大于box的height，解决方法是：将ball的中心点坐标 y 置为box.height - ball.radius并且ball的垂直运动方向反向 若碰撞到box的左边，则碰撞条件是：ball的中心点坐标 x 小于其自身半径 radius，解决方法是：将ball的中心点坐标 x 置为ball.radius并且ball的水平运动方向反向 若碰撞到box的右边，则碰撞条件是：ball的中心点坐标 x 与其自身半径 radius之和大于box的width，解决方法是：将ball的中心点坐标 x 置为box.width - ball.radius并且ball的水平运动方向反向 ball的实现是每次运动都重新渲染画布，所以，ball还需要一个draw的方法来完成自身的渲染 代码实现ball对象function Ball(radius,color){ if(radius === undefined) {radius = 40;} if(color === undefined){color = &apos;#00ff00&apos;;} this.x = 0; //中心点坐标x,y this.y = 0; this.vx = 0; //小球的水平及垂直运动方向 this.vy = 0; this.radius = radius; this.color = color; } box对象（即canvas）&lt;canvas id=&apos;canvas&apos; width=&quot;400&quot; height=&quot;300&quot; style=&quot;background:#000&quot;&gt;&lt;/canvas&gt; 碰撞规则ball.x = ball.x + ball.vx; //小球运动 ball.y = ball.y + ball.vy; //碰撞规则 if(ball.y &lt; ball.radius){ ball.y = ball.radius; ball.vy = ball.vy*(-1); } if(ball.y + ball.radius &gt; canvas.height){ ball.y = canvas.height - ball.radius; ball.vy = ball.vy*(-1); } if(ball.x &lt; ball.radius){ ball.x = ball.radius; ball.vx = ball.vx*(-1); } if(ball.x + ball.radius &gt; canvas.width){ ball.x = canvas.width - ball.radius; ball.vx = ball.vx*(-1); } 小球渲染Ball.prototype.draw = function(context){ context.save(); context.translate(this.x,this.y); context.fillStyle = this.color; context.strokeStyle = this.color; context.beginPath(); context.arc(0,0,this.radius,0,Math.PI*2,false); context.closePath(); context.fill(); context.stroke(); context.restore(); }","categories":[],"tags":[{"name":"animation","slug":"animation","permalink":"https://aiyuzhou.github.io/tags/animation/"},{"name":"canvas","slug":"canvas","permalink":"https://aiyuzhou.github.io/tags/canvas/"},{"name":"bouncing","slug":"bouncing","permalink":"https://aiyuzhou.github.io/tags/bouncing/"}]},{"title":"H5-Animation-canvas百分比加载","slug":"H5-Animation-canvas百分比加载","date":"2016-12-16T04:02:41.000Z","updated":"2016-12-16T08:17:59.000Z","comments":true,"path":"2016/12/16/H5-Animation-canvas百分比加载/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/16/H5-Animation-canvas百分比加载/","excerpt":"","text":"首先，代码源于supperjet，我是边看代码边学习记笔记。源码: canvas百分比加载 效果图是这样的: 代码解析drawFrame(function drawFrame(){ window.requestAnimationFrame(drawFrame, canvas); context.clearRect(0, 0, canvas.width, canvas.height); whiteCircle(); text(speed); blueCircle(speed); if(speed &gt; 100) speed = 0; speed += 0.1; }()); window.requestAnimationFrame(drawFrame, canvas);相当于是个递归吧，相当于是canvas每次调用一次drawFrame来重新渲染画布。 clearRect来清除画布内容，其实这里就很清楚了，canvas的动画效果只是视觉上的动画，并非真的一点一点在变，大概意思就是：我要把一段直线从1cm变到2cm，我是先画了1cm的线段，在把这个画布清除，然后在画2cm的线段，而不是视觉上的先画1cm，然后在1cm的基础上再画1cm。 代码解析whiteCirclefunction whiteCircle(){ context.save(); context.beginPath(); context.strokeStyle = &quot;white&quot;; context.arc(centerX, centerY, 100 , 0, Math.PI*2, false); context.stroke(); context.closePath(); context.restore(); console.log(&quot;whiteCircle&quot;); } whiteCircle()用来画白色的底线，底线一直都是完整圆，所以都是0，2π 代码解析textfunction text(n){ context.save(); context.strokeStyle = &quot;#49f&quot;; context.font = &quot;40px Arial&quot;; context.strokeText(n.toFixed(0)+&quot;%&quot;, centerX-25, centerY+10); context.stroke(); context.restore(); } text(speed)用来变化百分比这个n.toFixed(0)四舍五入保留一位，所以是从0~100 代码解析blueCirclefunction blueCircle(n){ context.save(); context.beginPath(); context.strokeStyle = &quot;#49f&quot;; context.lineWidth = 5; context.arc(centerX, centerY, 100 , -Math.PI/2, -Math.PI/2 +n*rad, false); context.stroke(); context.closePath(); context.restore(); } blueCircle(speed)蓝线表示进度条，每次都从-1/2π开始画到-1/2π + speed*rad(rad = 2π/100) window.requestAnimationFrame(drawFrame, canvas)是浏览器来调用的，自然在流畅性上比setInterval和setTimeout好，并且节省资源，如果用setInterval来实现 var timer = setInterval(function () { context.clearRect(0, 0, canvas.width, canvas.height); whiteCircle(); text(speed); blueCircle(speed); if(speed &gt; 100) { speed = 0; //clearInterval(timer);//如果只执行一次，在这里清除句柄就OK } speed += 0.1; },50); 同样window.requestAnimationFrame也会返回唯一表示requestID，可用window.cancelAnimationFrame()来取消回调函数.","categories":[],"tags":[{"name":"H5","slug":"H5","permalink":"https://aiyuzhou.github.io/tags/H5/"},{"name":"animation","slug":"animation","permalink":"https://aiyuzhou.github.io/tags/animation/"},{"name":"canvas","slug":"canvas","permalink":"https://aiyuzhou.github.io/tags/canvas/"}]},{"title":"写在最前面","slug":"写在最前面","date":"2016-12-15T08:29:14.000Z","updated":"2016-12-16T08:25:34.000Z","comments":true,"path":"2016/12/15/写在最前面/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/15/写在最前面/","excerpt":"","text":"终于，我开始写博客了 更新：为什么要写博客，我写博客的重要目的是记笔记，因为平时所谓的看懂了听懂了搞明白了，都是粗略的懂了，但是讲的时候很难讲清楚，我自己本来就有些不善表达，更准确的说是不善于组织语言，所以写博客记笔记的过程中其实是一个很好的思考过程，你要把问题说明白，这对自己来说我觉得是很大的提升，所以，保持一个书写的习惯是非常好的，我以后会把之前写的笔记慢慢整理上来。 写在最前面 除去前两篇的测试文章，这大概算是我非常正式的写在自己的博客里的第一篇文章了，为什么说是大概呢！！！原因是： 我很早很早之前就想开始写博客了，至于多早，应该是我刚刚入门前端的时候吧，那个时候每次在网上搜寻学习过程中遇到的一些问题时，见到不少形式的博客，有写在CSDN的，有博客园的，有简书的，有github的，于是啊，我就萌生了自己写一个博客系统的想法，现在想想真是可笑啊哈哈哈哈哈哈。。。那时用的是javaweb，最后的结果呢，就是写了些静态的漂亮的页面，简单的交互：有阅读全文跳转到整章阅读，在article页面，阅读全文则全部文章的wrap div设置为display：none,单个文章的wrap div设置为display：block，然后js将内容换位点击那篇文章的内容。恩，然后我意识到自己一个人写一个系统不现实，我开始动手写的时候就是脑子一热就开始写了，完全没有考虑到一个博客系统项目架构，模块，数据库存储，到最后部署上线不是我一个刚刚入门的小菜鸟能搞定的，终于认清楚以后，就在这里停下来。 我开始在印象笔记里零零散散的记一些知识，也在电脑创建过文件夹用markdown来记笔记，太零散了，整理的时候真希望有个标签一点就把我要的文章找出来。 所以，在这么长的时间过去之后，我快毕业了，我终于决定搭建我的博客，对，就是今天，斟酌一番后，决定用最简易的github Pages和hexo来搭建博客（之前非常蠢得准备自己写一个博客系统的时候，还没有开始用github，捂脸逃），选了个自己喜欢的主题，就这样我的真正的博客开通了。 记录目前生活状态我是Annie Chou，是一名程序媛，现在就读于西安电子科技大学，于明年7月毕业。目前在北京一家智能硬件创业公司实习，也打算继续留在这里工作。 希望自己可以在前端的路上摸爬打滚越滚越远！","categories":[],"tags":[]},{"title":"linux命令 chmod 755的含义","slug":"linux命令_chmod_755的含义","date":"2016-12-15T04:38:32.000Z","updated":"2016-12-15T05:27:41.000Z","comments":true,"path":"2016/12/15/linux命令_chmod_755的含义/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/15/linux命令_chmod_755的含义/","excerpt":"","text":"linux命令 chmod 755的含义chmod是Linux下设置文件权限的命令，后面的数字表示不同用户或用户组的权限。一般是三个数字：第一个数字表示文件所有者的权限第二个数字表示与文件所有者同属一个用户组的其他用户的权限第三个数字表示其它用户组的权限。 权限分为三种：读（r=4），写（w=2），执行（x=1） 。 综合起来还有可读可执行（rx=5=4+1）、可读可写（rw=6=4+2）、可读可写可执行(rwx=7=4+2+1)。 所以，chmod 755 设置用户的权限为： 1.文件所有者可读可写可执行 –72.与文件所有者同属一个用户组的其他用户可读可执行 –53.其它用户组可读可执行 –5","categories":[],"tags":[{"name":"chmod","slug":"chmod","permalink":"https://aiyuzhou.github.io/tags/chmod/"}]},{"title":"angular学习笔记（一）—— 创建自定义指令","slug":"angular学习笔记（一）——_创建自定义指令","date":"2016-12-15T04:19:32.000Z","updated":"2017-02-14T06:15:49.000Z","comments":true,"path":"2016/12/15/angular学习笔记（一）——_创建自定义指令/","link":"","permalink":"https://aiyuzhou.github.io/2016/12/15/angular学习笔记（一）——_创建自定义指令/","excerpt":"","text":"angular学习笔记（一）—— 创建自定义指令使用驼峰法来命名一个指令， runoobDirective, 但在使用它时需要以 - 分割, runoob-directive:实例： &lt;runoob-directive&gt;&lt;/runoob-directive&gt; &lt;script&gt; var app = angular.module(&quot;myApp&quot;, []); app.directive(&quot;runoobDirective&quot;, function() { return { template : &quot;&lt;h1&gt;自定义指令!&lt;/h1&gt;&quot; }; }); &lt;/script&gt; 元素名 &lt;runoob-directive&gt;&lt;/runoob-directive&gt; 属性 &lt;div runoob-directive&gt;&lt;/div&gt; 类名 &lt;div class=&quot;runoob-directive&quot;&gt;&lt;/div&gt; 注释 &lt;!-- directive: runoob-directive --&gt; 限制使用你可以限制你的指令只能通过特定的方式来调用。 实例 通过添加 restrict 属性,并设置只值为 “A”, 来设置指令只能通过属性的方式来调用: var app = angular.module(&quot;myApp&quot;, []); app.directive(&quot;runoobDirective&quot;, function() { return { restrict : &quot;A&quot;, template : &quot;&lt;h1&gt;自定义指令!&lt;/h1&gt;&quot; }; }); restrict 值可以是以下几种: E 作为元素名使用 A 作为属性使用 C 作为类名使用 M 作为注释使用 restrict 默认值为 EA, 即可以通过元素名和属性名来调用指令。","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"https://aiyuzhou.github.io/tags/angular/"}]}]}