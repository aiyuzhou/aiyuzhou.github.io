<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword" content="javascript,html,css,前端,angular,react,ionic">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="http://oi7koh9y1.bkt.clouddn.com/headImg.jpg">
    <link rel="alternate" type="application/atom+xml" title="Annie" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        JavaScript典型问题总结（一）｜Annie&#39;s blog
        
    </title>

    <link rel="canonical" href="https://aiyuzhou.github.io/2017/04/13/JavaScript典型问题总结（一）/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('http://oi7koh9y1.bkt.clouddn.com/backgroundImg2.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    Annie
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/tags/">tags</a>
                        </li>
							
						
                    
                        
							
                        <li>
                            <a href="/bable/">bable</a>
                        </li>
							
						
                    

					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="http://oi7koh9y1.bkt.clouddn.com/defaultImg.jpg">


<style>
    
    header.intro-header {
        background-image: url('http://oi7koh9y1.bkt.clouddn.com/defaultImg.jpg')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>JavaScript典型问题总结（一）</h1>
                    
                    <span class="meta">
                         作者 Annie Chou
                        <span>
                          日期 2017-04-13
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/#JavaScript"
                           title="JavaScript">JavaScript</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            JavaScript典型问题总结（一）
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h2 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h2><h3 id="JavaScript检测类型"><a href="#JavaScript检测类型" class="headerlink" title="JavaScript检测类型"></a>JavaScript检测类型</h3><p>检测数据类型有typeof、instanceof等方式</p>
<ul>
<li><p>typeof是检测字符串、数值、布尔值还有undefined的最佳工具，还可以检测function类型，并且typeof返回值都是字符串形式，</p>
<pre><code>var str = &quot;hhhh&quot;;
var b = true;
var num = 22;
var u;
var n = null;
var obj = new Ojbect();
var fun = function(){};

console.log(typeof(str));  //string
console.log(typeof(b));    //boolean
console.log(typeof(num));  //number
console.log(typeof(u));    //undefined
console.log(typeof(n));    //object
console.log(typeof(obj));  //object
console.log(typeof([]));   //object
console.log(typeof(fun));  //function
</code></pre></li>
<li><p>通过面的代码示例，你会发现当用typeof检测引用类型时都会显示object</p>
</li>
<li><p>当我们想知道变量到底是什么类型的对象时，ECMAStript提供了instanceof操作符</p>
<pre><code>//语法如下：
result = variable instanceof constructor
//意为 变量variable是构造函数constructor的实例
</code></pre></li>
<li><p>使用instanceof检测引用类型，类型一定是对象类型，大小写要注意</p>
<pre><code>console.log(person instanceof Object); //true
console.log(arr instanceof Array);     //true
console.log(pattern instanceof RegExp);//true
</code></pre></li>
<li><p>若使用instanceof检测基本类型，则会返回false，因为基本类型不是对象</p>
</li>
<li><p>使用对象的constructor判断其构造函数</p>
<pre><code>console.log(arr.constructor === Array);  //true
console.log(date.constructor === Date);  //true
console.log(fun.constructor === Function);//true
</code></pre></li>
<li><p>使用constructor检测对象类型时要注意：<code>实现继承时，一定要将constructor属性手动更改</code>，否则检测会出错</p>
<pre><code>function parent(){}
function child(){}
child.prototype = new parent(); //child继承parent
var obj = new child();
console.log(obj.constructor === child);  //false
console.log(obj.constructor === parent); //true
</code></pre></li>
<li><p>要避免这种情况，一定要在原型继承的时候，手动将原型的构造函数修改为本身</p>
<pre><code>child.prototype.constructor = child;
console.log(obj.constructor === child);  //true
console.log(obj.constructor === parent); //false
</code></pre></li>
<li><p>通用的方法，但不能检测自定义类型</p>
<pre><code>Object.prototype.toString.call(variable); //返回类似[object String],[object Array]等形式来直接判断类型，一般情况用typeof就够了
</code></pre></li>
</ul>
<h3 id="JavaScript基本数据类型"><a href="#JavaScript基本数据类型" class="headerlink" title="JavaScript基本数据类型"></a>JavaScript基本数据类型</h3><p>JavaScript有五种基本数据类型：undefined，Null，Boolean，Number和String</p>
<ul>
<li>Undefined类型：<ul>
<li>Undefined类型只有一个值，即特殊值undefined</li>
<li>在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined</li>
<li>是定义了但尚未初始化其值，不等同于未定义的变量</li>
<li>但是用typeof检测时两者都为undefined</li>
</ul>
</li>
<li>Null类型：<ul>
<li>Null类型也是只有一个值，即特殊值null</li>
<li>从逻辑上null值表示一个空对象指针，所以typeof检测null返回‘object’ </li>
<li>如果定义的变量准备用来保存对象，那么最好将该变量初始化为null而不是其他值</li>
</ul>
</li>
<li>Boolean类型：<ul>
<li>Boolean类型有两个值true和false</li>
<li>要将一个值转换为其对应的Boolean值，可以直接调用转型函数Boolean()</li>
<li>| 数据类型        | 转换为true的值    |  转换为false的值  |<br>| ——–   | —–:   | :—-: |<br>| Boolean        | true      |   false    |<br>| String        | 任何非空字符串      |   “”(空字符串)    |<br>| Number        | 任何非零数字值      |   0和NaN    |<br>| Object        | 任何对象      |   null    |<br>| Undefined        | 不适用      |   undefined    |</li>
<li>流控制语句（如if）将自定执行相应的Boolean转换</li>
</ul>
</li>
<li>Number类型：<ul>
<li>Number类型的数字值包括整数和浮点数</li>
<li>浮点数值中必须包含一个小数点，并且小数点后面必须至少一位有效数字</li>
<li>数值范围限制在Number.MAX_VALUE ~ Number.MIN_VALUE之间</li>
<li>还有一个特殊值NaN，用于表示一个本来要返回数值的操作符未返回数值的情况（这样就不会抛出错误了），比如任何数值除以0会导致错误，在其他语言中会停止代码执行。但是在ECMAScript中，返回NaN，但不会影响一塔代码执行。</li>
</ul>
</li>
<li><p>String类型:</p>
<ul>
<li>用双引号或者单引号表示</li>
<li><p>一旦被创建，他们的值就不能改变，除非通过销毁原来的字符串，然后用另一个包含新值得字符串填充该变量</p>
<pre><code>var lang = &quot;Java&quot;;
lang = lang + &quot;Script&quot;;
//以上两行代码执行过程如下：首先创建一个能容纳10个字符串的新字符串，然后在这个字符串中填充“Java”和“Script”，最后销毁原来的字符串“Java”和“Script”，因为这两个字符串没有任何用了，当然这个过程是在后台发生的。
</code></pre></li>
<li>将一个值转换为字符串有两种方式：<ul>
<li>第一种是调用toString()方法，但是null和undefined没有这个方法；</li>
<li>第二种是使用转型函数String()，转换规则如下：<ul>
<li>如果值有toString()方法，则调用该方法</li>
<li>如果值是null，则返回“null”</li>
<li>如果值是undefined，则返回“undefined”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="JavaScript复杂数据类型（引用类型）"><a href="#JavaScript复杂数据类型（引用类型）" class="headerlink" title="JavaScript复杂数据类型（引用类型）"></a>JavaScript复杂数据类型（引用类型）</h3><p>JavaScript有Object，Array，Date，RegExp，Function，基本包装类型等复杂数据类型</p>
<ul>
<li><p>Object类型：</p>
<ul>
<li>Object其实是一组数据和功能的集合。</li>
<li><p>对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。</p>
<pre><code>var person = new Object();
person.name = &quot;annie&quot;;
person.age = 22;
</code></pre></li>
<li><p>对象字面量表示法</p>
<pre><code>var person = {
    name : &quot;annie&quot;,
    age : 22
}
//使用以上字面量法，读取属性值时只能以person.name读

var anotherperson = {
    &quot;name&quot; : &quot;annie&quot;,
    &quot;age&quot; : 22
}
//使用第二种字面量法，读取属性值既可以用anotherperson.name读取，也可以使用下标法anotherperson[&quot;name&quot;]来读取

var anothertwoperson = {
    &quot;first name&quot; : &quot;annie&quot;,
    &quot;age&quot; : 22
}
//不能使用点表示法来访问，这时方括号表示法就有很好的用处了
</code></pre></li>
</ul>
</li>
<li><p>Array类型</p>
<ul>
<li>数组的大小可动态调整</li>
<li>数组的数据类型可不同，即第一项是字符串，第二项是数值，第三项是对象等等</li>
<li>可以用new操作符，也可以省去new操作符，或者直接用数组字面量表示法</li>
<li>栈方法：<ul>
<li>push() 添加到数组尾部</li>
<li>pop() 从数组末尾移除最后一项</li>
</ul>
</li>
<li>队列方法：<ul>
<li>push() 添加到数组尾部</li>
<li>shift() 从数组前端移除第一个项</li>
</ul>
</li>
<li>反向队列方法：<ul>
<li>unshift() 添加到数组前端</li>
<li>pop() 从数组末尾移除最后一项</li>
</ul>
</li>
<li><p>重排序方法：</p>
<ul>
<li>reverse() 反转数组</li>
<li>sort() 按照升序排列数组项(先针对每项调用toString()方法，比较得到的字符串)</li>
<li><p>若不想按照默认比较字符串法来排序，课传入一个比较函数，例如：传入以下比较函数，则会按照升序排序</p>
<pre><code>function compare (value1,value2){
    //第一个参数小于第二个参数，应该排在第二个参数前面，所以返回-1
    //第一个参数大于第二个参数，应该排在第二个参数后面，所以返回1
    //两个参数相等，则返回0
    if(value1 &lt; value2){
        return -1;
    } else if(value1 &gt; value2){
        return 1;
    } else {
        return 0;
    }
}
</code></pre></li>
</ul>
</li>
<li><p>操作方法：</p>
<ul>
<li>concat() 基于当前数组的所有项创建一个新数组，先创建一个当前数组的副本，再将接受到的参数添加到该副本的末尾，最后返回新构建的数组</li>
<li>slice() 基于当前数组的一个或者多个项创建一个新数组<ul>
<li>接收一个参数，则返回从该指定位置到数组末尾位置的所有项、</li>
<li>接收两个参数，则返回从该指定位置到结束位置但不包括结束位置的所有项</li>
</ul>
</li>
<li>splice() 有三个个参数：<ul>
<li>splice(起始位置，要删除的项数，要插入的项)</li>
<li>删除：指定起始位置，和要删除的项</li>
<li>插入：指定起始位置，要删除的项数：0，要插入的项</li>
<li>替换：指定起始位置，要删除的项数，要插入的项</li>
</ul>
</li>
</ul>
</li>
<li>位置方法：<ul>
<li>indexof() 从数组的开头开始向后查找第一个值为参数的索引</li>
<li>lastIndexof() 从数组的末尾开始查找第一个值为参数的索引</li>
</ul>
</li>
<li>迭代方法：<ul>
<li>every() 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true</li>
<li>filter() 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组</li>
<li>forEach() 对数组中的每一项运行给定函数，这个方法没有返回值</li>
<li>map() 对数组中的每一项运行给定函数，返回每项函数调用的结果组成的数组</li>
<li>some() 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true</li>
</ul>
</li>
<li>归并方法：<ul>
<li>reduce() 从数组的第一项开始，逐个遍历到最后</li>
<li>reduceRight() 从数组的最后一项开始，向前遍历到第一项</li>
<li>以上两个方法均接收一个函数，并带有四个参数，分别是前一个值，当前值，项的索引，数组对象</li>
</ul>
</li>
</ul>
</li>
<li>Date类型：</li>
<li>RegExp类型：<ul>
<li>var expression = / pattern / flags；</li>
<li>由一个模式和一个或者多个标志构成<ul>
<li>g：表示全局模式</li>
<li>i：表示不区分大小写模式</li>
<li>m：表示多行模式</li>
</ul>
</li>
</ul>
</li>
<li><p>Function类型：</p>
<ul>
<li>在使用new Function(arg1,arg2,arg3,…,sentence)创建函数时，最后一个参数被解析为函数体，其余均被解析为参数</li>
<li>每个函数都是Function类型的实例</li>
<li>没有重载</li>
<li><p>解析器在向执行环境中加载数据时，对于函数声明和函数表达式并非一视同仁</p>
<ul>
<li>解析器会率先读取函数声明，并使其在执行任何代码之前可用</li>
<li><p>至于函数表达式，则必须等到解析器执行到他所在的代码行，才会被解释执行</p>
<pre><code>alert(sum(10,10))
function sum(num1,num2){
    return num1+num2;
}

alert(sum(10,10))//报错
var sum = function(num1,num2){
    return num1+num2;
}
</code></pre></li>
</ul>
</li>
<li>函数内部属性<ul>
<li>函数内部有两个特殊的对象：arguments和this</li>
<li>arguments主要用来保存函数参数，但这个对象还有一个名叫callee的属性，是一个指向拥有这个arguments对象的函数的指针</li>
<li>ES5规范了另一个函数对象的属性：caller，保存着调用当前函数的引用</li>
<li>length：函数希望接收的命名参数的个数</li>
<li>prototype：保存它们所有实例方法的真正所在    </li>
<li>apply() apply(函数执行的作用域,arguments)    </li>
<li>call() call(函数执行的作用域,arguments[0],arguments[2],…)</li>
</ul>
</li>
</ul>
</li>
<li><p>基本包装类型：</p>
<ul>
<li><p>实际上，读取一个基本类型时，后台就会自动创建一个基本包装类型的对象</p>
<pre><code>var s1 = &quot;some text&quot;;
var s2 = s1.substring(2);
//从逻辑上讲，基本类型值不是对象，不应该有方法
//实际上，读取s1时，后台会自动完成以下处理
    1.创建String类型的一个实例
    2.在实例上调用指定的方法
    3.销毁这个实例
//所以基本包装类型是不能添加属性的，因为在执行瞬间后立即销毁
</code></pre></li>
</ul>
</li>
<li>单体内置对象<ul>
<li>Global对象：全局属性和方法都是属于Global对象的</li>
<li>Math对象：</li>
</ul>
</li>
</ul>
<h2 id="JavaScript中运算符优先级"><a href="#JavaScript中运算符优先级" class="headerlink" title="JavaScript中运算符优先级"></a>JavaScript中运算符优先级</h2><h2 id="JavaScript事件委托"><a href="#JavaScript事件委托" class="headerlink" title="JavaScript事件委托"></a>JavaScript事件委托</h2><p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件，只需在DOM树中尽量最高的层次上添加一个事件处理程序，事件委托不仅可以使代码简洁整齐，同时也可以减少内存占用，提高效率，例子如下：</p>
<pre><code>&lt;ul id=&quot;myLinks&quot;&gt;
    &lt;li id=&quot;goSomewhere&quot;&gt;Go somewhere&lt;/li&gt;
    &lt;li id=&quot;doSomething&quot;&gt;Do something&lt;/li&gt;
    &lt;li id=&quot;sayHi&quot;&gt;Say hi&lt;/li&gt;
&lt;/ul&gt;



var list = document.getElementById(&quot;myLinks&quot;);
EventUtil.addHandler(list, &quot;click&quot;, function(event){
    event = EventUtil.getEvent(event);
    var target = EventUtil.getTarget(event);
    switch(target.id){
        case &quot;doSomething&quot;:
            document.title = &quot;I changed the document&apos;s title&quot;;
            break;
        case &quot;goSomewhere&quot;:
            location.href = &quot;http://www.wrox.com&quot;;
            break;
        case &quot;sayHi&quot;: 9 alert(&quot;hi&quot;);
            break; }
});
</code></pre><h4 id="使用实例："><a href="#使用实例：" class="headerlink" title="使用实例："></a>使用实例：</h4><h6 id="jQuery中"><a href="#jQuery中" class="headerlink" title="jQuery中"></a>jQuery中</h6><ul>
<li>bind()方法：直接绑定在元素上，或者是多个事件处理程序，也可以传入需要的参数</li>
<li>live()方法：通过冒泡的方式绑定到元素上，绑定到documentDOM节点上，之所以能都给未来元素添加事件处理程序，就是因为绑定到了document DOM节点上的缘故，只有一次事件绑定，不同于bind方法，给所有元素挨个绑定</li>
<li>delegate()方法：绑定事件处理程序到指定事件代理父容器，缩小了范围的事件代理</li>
<li>on()方法：实际上是整合了前三种的一种新事件绑定机制</li>
</ul>
<h2 id="JavaScript事件流"><a href="#JavaScript事件流" class="headerlink" title="JavaScript事件流"></a>JavaScript事件流</h2><p>事件流描述的是从页面中接收事件的顺序</p>
<h5 id="事件冒泡：IE的事件流叫作事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较不具体的节点（document对象）"><a href="#事件冒泡：IE的事件流叫作事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较不具体的节点（document对象）" class="headerlink" title="事件冒泡：IE的事件流叫作事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较不具体的节点（document对象）"></a>事件冒泡：IE的事件流叫作事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较不具体的节点（document对象）</h5><h5 id="事件捕获：Netscape提出另一种事件流叫做事件捕获，即事件熊不太具体的节点（document对象）沿着DOM树依次向下，一直传播到事件的实际目标（具体的节点）"><a href="#事件捕获：Netscape提出另一种事件流叫做事件捕获，即事件熊不太具体的节点（document对象）沿着DOM树依次向下，一直传播到事件的实际目标（具体的节点）" class="headerlink" title="事件捕获：Netscape提出另一种事件流叫做事件捕获，即事件熊不太具体的节点（document对象）沿着DOM树依次向下，一直传播到事件的实际目标（具体的节点）"></a>事件捕获：Netscape提出另一种事件流叫做事件捕获，即事件熊不太具体的节点（document对象）沿着DOM树依次向下，一直传播到事件的实际目标（具体的节点）</h5><h5 id="DOM事件流：包括事件捕获阶段，处于目标阶段，和事件冒泡阶段"><a href="#DOM事件流：包括事件捕获阶段，处于目标阶段，和事件冒泡阶段" class="headerlink" title="DOM事件流：包括事件捕获阶段，处于目标阶段，和事件冒泡阶段"></a>DOM事件流：包括事件捕获阶段，处于目标阶段，和事件冒泡阶段</h5><h2 id="JavaScript中Global对象，window对象，document对象的区别"><a href="#JavaScript中Global对象，window对象，document对象的区别" class="headerlink" title="JavaScript中Global对象，window对象，document对象的区别"></a>JavaScript中Global对象，window对象，document对象的区别</h2><ul>
<li>Global对象是JavaScript运行时所在的宿主环境提供的全局对象，是一个Object。最常见的宿主环境是浏览器和nodejs，它只是一个抽象的概念。</li>
<li>window对象就是浏览器引擎对Global对象的封装</li>
<li>Document对象：每个被浏览器载入的HTML文档都会成为Document对象，而Document对象，是window对象的一部分，可以直接通过document访问，也可通过window.document属性进行访问</li>
</ul>
<h2 id="JavaScript中的this"><a href="#JavaScript中的this" class="headerlink" title="JavaScript中的this"></a>JavaScript中的this</h2><ul>
<li>首先，this是JavaScript中的一个关键字</li>
<li>它是在函数运行时，自动生成的一个内部对象，只能在函数内部使用</li>
<li>根据函数的使用场景不同，this的值也会发生变化</li>
<li>但总的原则是：this始终指向调用函数的那个对象</li>
</ul>
<h4 id="情况一：纯粹的函数调用"><a href="#情况一：纯粹的函数调用" class="headerlink" title="情况一：纯粹的函数调用"></a>情况一：纯粹的函数调用</h4><p>这是函数的最通常用法，属于全局性调用，此时的this就指代全局对象Global对象；</p>
<pre><code>function test(){
    this.x = 1;
    alert(this.x);
}
test();//1
</code></pre><p>### </p>
<pre><code>var x = 1;//此时的x是全局对象Global的属性
function test(){
    alert(this.x);
}
test();//1；所以全局环境下this指代Global对象
</code></pre><p>### </p>
<pre><code>var x = 1;
function test(){
    this.x = 0; //改变全局属性x的值
}
test();
alert(x);//0
</code></pre><p>所以在全局环境运行的函数，相当于是全局对象的属性，即这种函数执行时相当于是Global对象调用的，所以this指代全局对象Global。</p>
<h4 id="情况二：作为对象方法的调用"><a href="#情况二：作为对象方法的调用" class="headerlink" title="情况二：作为对象方法的调用"></a>情况二：作为对象方法的调用</h4><p>函数作为某个函数的方法调用时，这时的this指代这个对象。</p>
<pre><code>function test(){
    alert(this.x);
}
var o = {};
o.x = 1;
o.fun = test;
o.fun();//1  此时对象o的方法指向test函数，这时的this就指代调用此方法的对象
</code></pre><h4 id="情况三：作为构造函数调用"><a href="#情况三：作为构造函数调用" class="headerlink" title="情况三：作为构造函数调用"></a>情况三：作为构造函数调用</h4><p>所谓构造函数，就是通过这个函数生成一个新对象，这时的this将会指向这个新对象。</p>
<pre><code>function test(){
    this.x = 1;
}
var o = new test();
alert(o.x); //1
</code></pre><p>### </p>
<pre><code>var x = 2;
function test(){
    this.x = 1;
}
var o = new test();
alert(x);//2  若this是Global对象的话，x将会在创建o对象的时候改变成1，所以作为构造函数调用时，this指向新对象。
</code></pre><h4 id="情况四：apply调用"><a href="#情况四：apply调用" class="headerlink" title="情况四：apply调用"></a>情况四：apply调用</h4><p>apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象，所以此时的this指代第一个参数。</p>
<pre><code>var x = 0;
function test (){
    alert(this.x)
}

var obj = {};
obj.x = 1;
obj.fun = test;
obj.fun.apply();//0
obj.fun.apply(obj);//1
obj.fun.apply(this);//0
</code></pre><p>apply()的参数为空的时候，默认调用全局对象，所以此时this指代全局对象。若传入o作为执行函数的作用域，则this指代o。需要区别的是最后一个传入this作为函数的执行作用域时，因为是在全局环境调用的，所以此时this指代Global，x仍为全局对象属性x的值，即为0。</p>
<h2 id="JavaScript中的new"><a href="#JavaScript中的new" class="headerlink" title="JavaScript中的new"></a>JavaScript中的new</h2><p>一般看到new会想到生成一个实例对象，但在JavaScript中new存在的意义更多是实现JavaScript中的继承机制</p>
<p>先看一个new创建对象的例子：</p>
<pre><code>function Person(type,name){
    this.type = type;
    this.name = name;
}
Person.race = &quot;People&quot;;
Person.prototype.say = function(){
    console.log(&quot;I&apos;m a &quot; + this.type + &quot;,my name is &quot; + this.name);
}
var student1 = new Person(&quot;student&quot;,&quot;annie&quot;);
console.log(student1.type,student1.name,student1.race);//student,annie,undefined
student1.say();//I&apos;m a student,my name is annie

console.log(Person.name,Person.race);//Person,People
Person.say();//Person.say not a function
</code></pre><p>new 的执行机制</p>
<pre><code>new Person(&quot;student&quot;,&quot;annie&quot;) = {
    var obj = {};
    obj._proto_ = Person.prototype;
    //这里可以结合this来理解，在obj对象的执行环境调用Person函数并传入参数&quot;student&quot;和&quot;annie&quot;,Person.call 传入了执行作用域obj，则this指向obj,所以obj.type = &quot;student&quot;,obj.name = &quot;annie&quot;
    var result = Person.call(obj,&quot;student&quot;,&quot;annie&quot;);
    return typeof result === &quot;object&quot; ? result : obj;
}
</code></pre><p>证明student1是Person的实例：</p>
<pre><code>student1 instanceof Person;//true 
</code></pre><p>instanceof的执行规则是：</p>
<pre><code>var L = A._proto_;
var R = B.prototype;
if(L===R) return true;
</code></pre><p>则证明A是B的实例，在生成student1时，student1.<em>proto</em>确实被赋值为Person.prototype</p>
<h2 id="JavaScript继承机制的设计思想"><a href="#JavaScript继承机制的设计思想" class="headerlink" title="JavaScript继承机制的设计思想"></a>JavaScript继承机制的设计思想</h2><p>继承的关键是一个对象可以调用另一个对象的属性方法。</p>
<ul>
<li><p>首先，按照传统面向对象语言的对象实例生成的方法</p>
<ul>
<li><p>比如Java：</p>
<pre><code>class Person {
    public void eat(){
        System.out.println(&quot;person eat&quot;);
    }
}

public class Student extends Person{

}
//此时子类Student将继承父类Person的eat()方法
</code></pre></li>
<li><p>而JavaScript为了不增加入门难度，没有引入类的概念，而是直接通过<code>new+构造函数</code>来生成一个对象的实例，但是直接从构造函数生成实例对象不能满足属性方法共享的这种机制，比如：</p>
<pre><code>function Person (name){
    this.name = name;
    this.type = &quot;person&quot;;//假设此时想设计type为对象的共享属性
}
var person1 = new Person(&quot;bbn&quot;);
var person2 = new Person(&quot;mk&quot;);
person1.type = &quot;student&quot;;
alert(person2.type);//person，无法共享数据，浪费了资源
</code></pre></li>
<li><h5 id="所以引入了原型prototype："><a href="#所以引入了原型prototype：" class="headerlink" title="所以引入了原型prototype："></a>所以引入了原型prototype：</h5><p>JavaScript在设计的时候，为构造函数设计了一个prototype属性，专门用来存放共享属性和方法，不需要共享的则直接放在构造函数里。使用构造函数new一个实例对象的同时将自动引用这个构造函数的prototype对象的属性和方法。从而实现对象的继承：</p>
<pre><code>function Person(name){
    this.name = name;//这个属性将是每个实例对象独立的属性，相互不受影响
}
Person.prototype = {type:&quot;person&quot;};//原型对象中存放共享属性和方法
var person1 = new Person(&quot;bbn&quot;);
var person2 = new Person(&quot;mk&quot;);
//要修改type只能通过构造函数的原型对象进行修改
Person.prototype.type = &quot;student&quot;;
alert(person2.type);//student
</code></pre></li>
</ul>
</li>
</ul>
<h2 id="JavaScript创建对象"><a href="#JavaScript创建对象" class="headerlink" title="JavaScript创建对象"></a>JavaScript创建对象</h2><p>工厂模式</p>
<pre><code>function createPerson(name, age, job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    };
    return o; 
}
</code></pre><p>构造函数模式</p>
<pre><code>function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
        alert(this.name);
    }; 
}
</code></pre><p>原型模式：所以都添加到原型中</p>
<pre><code>function Person(){
}
Person.prototype.name = &quot;Nicholas&quot;;
Person.prototype.age = 29;
Person.prototype.job = &quot;Software Engineer&quot;;
Person.prototype.sayName = function(){
    alert(this.name);
};
</code></pre><p>组合使用构造函数和原型模式</p>
<pre><code>function Person(name, age, job){
    this.name = name; 3 this.age = age;
    this.job = job;
    this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];
}
Person.prototype = {
    constructor : Person,
    sayName : function(){
        alert(this.name);
    }
}
</code></pre><p>动态原型模式</p>
<pre><code>function Person(name, age, job){
    this.name = name; 
    this.age = age; 
    this.job = job;

    // 
    if (typeof this.sayName != &quot;function&quot;){
        Person.prototype.sayName = function(){
            alert(this.name);
    }; }
}
</code></pre><h2 id="JavaScript的继承实现"><a href="#JavaScript的继承实现" class="headerlink" title="JavaScript的继承实现"></a>JavaScript的继承实现</h2><h3 id="JavaScript对对象的封装"><a href="#JavaScript对对象的封装" class="headerlink" title="JavaScript对对象的封装"></a>JavaScript对对象的封装</h3><h4 id="一、最原始的生成对象模式"><a href="#一、最原始的生成对象模式" class="headerlink" title="一、最原始的生成对象模式"></a>一、最原始的生成对象模式</h4><p>创建一个对象，给它添加属性和方法</p>
<pre><code>var student = {};
student.name = &quot;annie&quot;;
student.study = function (){
    //study
}
</code></pre><h4 id="二、原始模式改进"><a href="#二、原始模式改进" class="headerlink" title="二、原始模式改进"></a>二、原始模式改进</h4><p>封装一个具有返回值对象的函数，解决代码重复的问题</p>
<pre><code>function student(name){
    return {
        name:name
    }
}    
</code></pre><h4 id="三、构造函数模式"><a href="#三、构造函数模式" class="headerlink" title="三、构造函数模式"></a>三、构造函数模式</h4><p>构造函数使用this变量，在使用new生成实例的时候，this将会指向这个新的实例对象</p>
<pre><code>function student(name){
    this.name = name;
}
//这样生成的实例对象将会有有一个constructor属性值都为student，表示student为他们的构造函数
</code></pre><h4 id="四、prototype模式"><a href="#四、prototype模式" class="headerlink" title="四、prototype模式"></a>四、prototype模式</h4><p>即将需要共享的属性和方法添加到构造函数的原型中</p>
<h3 id="JavaScript中构造函数的继承"><a href="#JavaScript中构造函数的继承" class="headerlink" title="JavaScript中构造函数的继承"></a>JavaScript中构造函数的继承</h3><p>思考，如何让student继承Person的属性：</p>
<pre><code>function Person(){
    this.species = &quot;People&quot;;
}
function student(name){
    this.name = name;
    this.type = &quot;student&quot;;
}
</code></pre><h4 id="一、构造函数绑定"><a href="#一、构造函数绑定" class="headerlink" title="一、构造函数绑定"></a>一、构造函数绑定</h4><p>使用call或者apply将父对象的构造函数绑定在子对象上</p>
<pre><code>function student(name){
    //添加这一行，实际上当new创建一个新的对象时，相当于是在新对象的执行环境内执行this.species=&quot;People&quot;，所以student将会继承Person的属性
    Person.apply(this,arguments);
    this.name = name;
    this.type = &quot;student&quot;;
}
</code></pre><h4 id="二、prototype模式"><a href="#二、prototype模式" class="headerlink" title="二、prototype模式"></a>二、prototype模式</h4><p>所以共享的属性和方法设置在构造函数的prototype属性中</p>
<pre><code>student.prototype = new Person();//加了这一句后，student.prototype.constructor = Person，所以需要手动纠正
student.prototype.constructor = student;
</code></pre><h4 id="三、直接继承prototype"><a href="#三、直接继承prototype" class="headerlink" title="三、直接继承prototype"></a>三、直接继承prototype</h4><p>待补充。。。</p>
<h2 id="JavaScript实现浅拷贝和深拷贝"><a href="#JavaScript实现浅拷贝和深拷贝" class="headerlink" title="JavaScript实现浅拷贝和深拷贝"></a>JavaScript实现浅拷贝和深拷贝</h2><p>浅拷贝实现：</p>
<pre><code>function extendCopy(p){
    var c = {};
    for(var i in p){
        c[i] = p[i];
    }
    c.uber = p;
    return c;
}
</code></pre><p>深拷贝就是实现真正意义上的数组和对象的拷贝，其实就是递归浅拷贝：</p>
<pre><code>function deepCopy(p,c){
    var c = c || {};
    for(var i in p){
        if(typeof(p[i]) === &apos;object){
            c[i] = (p[i].contructor === Array) ? [] : {};
            deepCopy(p[i],c[i]);
        } else {
            c[i] = p[i];
        }
    }
    return c;
}
</code></pre><h2 id="XMLHttpRequest对象深入理解"><a href="#XMLHttpRequest对象深入理解" class="headerlink" title="XMLHttpRequest对象深入理解"></a>XMLHttpRequest对象深入理解</h2><ul>
<li>AJAX = Asynchronous JavaScript and XML (异步的JavaScript和XML)</li>
<li>而XMLHttpRequest对象是AJAX的基础。用于在后台与服务器交换数据</li>
<li>创建XMLHttpRequest对象<ul>
<li>var xhr = new XMLHttpRequest();</li>
<li>var xhr = new ActiveXObject(“Mircosoft.XMLHTTP”);//针对IE5、6</li>
</ul>
</li>
<li>向服务器发送请求<ul>
<li>xhr.open(“GET”,”url”,true);//true则异步发送请求，false则同步发送请求</li>
<li>xhr.send();</li>
</ul>
</li>
<li>get请求和post请求<ul>
<li>get请求：最常见的请求类型，速度更快，更简单，可传少量经过正确编码的参数</li>
<li>post请求：通常用于给服务器发送应该被保存的数据，post可以包含很多数据，且不受格式的限制，参数通过send方法来传递</li>
</ul>
</li>
<li>HTTP头部信息<ul>
<li>默认情况下，在发送XHR请求的同时，还会发送下列头部信息</li>
<li>Accept：浏览器能够处理的内容信息</li>
<li>Accept-Encoding：刘安琪能都处理的压缩编码</li>
<li>Accept-Charset：浏览器能够显示的字符集</li>
<li>Accept—Language：浏览器当前设置的语言</li>
<li>Connection：浏览器与服务器之间的连接类型</li>
<li>Cookie：当前页面设置的任何Cookie</li>
<li>Host：发出请求的页面所在的域</li>
<li>Referer：发送请求的页面的URL</li>
<li>User-Agent：浏览器的用户代理字符串</li>
</ul>
</li>
<li>请求头部信息可以使用setRequestHeader方法来设置，此方法放在open之后send之前</li>
<li>getAllResponseHeaders()方法可以取得所有响应头部信息</li>
<li>xhr对象在响应后自动填充响应数据<ul>
<li>responseText：作为响应主体被返回的文本</li>
<li>responseXML：如果响应的内容类型是“text/xml”或者“application/xml”,这个属性中将保存包含着响应数据的XML DOM文档</li>
<li>status：响应的HTTP状态</li>
<li>statusText：HTTP状态说明</li>
</ul>
</li>
<li>onreadystatechange事件<ul>
<li>每当readyState改变时都会触发onreadystatechange事件</li>
<li>readyState<ul>
<li>0：请求未初始化</li>
<li>1：服务器连接已建立（说明已经调用了open方法）</li>
<li>2：请求已接收（已经调用了send方法）</li>
<li>3：请求处理中（已经开始接受响应的数据）</li>
<li>4：请求已完成，且响应就绪（已经接收到全部数据）</li>
</ul>
</li>
<li>status<ul>
<li>200：OK</li>
<li>404：未找到页面</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="原生JavaScript实现ajax请求"><a href="#原生JavaScript实现ajax请求" class="headerlink" title="原生JavaScript实现ajax请求"></a>原生JavaScript实现ajax请求</h3><pre><code>var xhr;
function createXMLHttpRequest(){
    if(XMLHttpRequest){
        xhr = new XMLHttpRequest();
    } else if(window.ActiveXObject){
        xhr = new ActiveXObject(&quot;MircoSoft.XMLHTTP&quot;);
    }
}

function sendAjax(){
    createXMLHttpRequest();
    xhr.open(&quot;GET&quot;,&quot;url&quot;,true);
    xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
    xhr.onreadystatechange = callback;
    xhr.send();
}

function callback(){
    if(xhr.readyState == 4){
        if(xhr.status == 200){
            var result = xhr.responseText;
            //...
        }
    }
}
</code></pre><h2 id="跨域的实现方式"><a href="#跨域的实现方式" class="headerlink" title="跨域的实现方式"></a>跨域的实现方式</h2><p>首先理解为什么需要跨域编程，因为JavaScript有同源策略的限制，所以先来看同源策略是什么</p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>baidu.com：形式的是一级或者顶级域名<br>www.baidu.com：形式的是二级域名，即www只是一个主机名</p>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>假设任何人在任何情况下都可以随意对一个网页进行修改，那么网站将会不安全，所以当时Netscape公司给浏览器引入了同源策略，浏览器之所以能安全应用到现在，就是同源策略的应用</p>
<h4 id="引入同源策略的目的：为了保证用户的信息安全，防止恶意的网站窃取数据"><a href="#引入同源策略的目的：为了保证用户的信息安全，防止恶意的网站窃取数据" class="headerlink" title="引入同源策略的目的：为了保证用户的信息安全，防止恶意的网站窃取数据"></a>引入同源策略的目的：为了保证用户的信息安全，防止恶意的网站窃取数据</h4><h4 id="所谓同源指的是"><a href="#所谓同源指的是" class="headerlink" title="所谓同源指的是"></a>所谓同源指的是</h4><ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<p>即除非A和B网页同源，否则A网页设置的Cookie，B网页不能打开</p>
<h4 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h4><p><code>http://www.baidu.com/dir/page.html</code>这个网址，它的协议是<a href="http://，域名是www.baidu.com，端口默认为80，它的同源情况：" target="_blank" rel="external">http://，域名是www.baidu.com，端口默认为80，它的同源情况：</a></p>
<ul>
<li><code>http://www.baidu.com/dir2/otherpage.html</code>：同源，因为协议，域名和端口均相同</li>
<li><code>http://baidu.com/dir/otherpage.html</code>：不同源（域名不同）</li>
<li><code>http://v.www.baidu.com/dir/otherpage/.html</code>：不同源（域名不同）</li>
<li><code>http://www.baidu.com:81/dir/otherpagel.html</code>：不同源（端口不同）</li>
<li><code>https://www.baidu.com/dir/hhh.html</code>：不同源（协议不同）</li>
</ul>
<h4 id="目前非同源时，共有三种行为受到限制"><a href="#目前非同源时，共有三种行为受到限制" class="headerlink" title="目前非同源时，共有三种行为受到限制"></a>目前非同源时，共有三种行为受到限制</h4><ul>
<li>cookie、localstorage和indexDB无法读取</li>
<li>DOM无法获得</li>
<li>ajax请求不能发送</li>
</ul>
<h3 id="cookie跨域规避方式"><a href="#cookie跨域规避方式" class="headerlink" title="cookie跨域规避方式"></a>cookie跨域规避方式</h3><ul>
<li>每个cookie都是一个名/值对，要一次性存储多个cookie需要用分号隔开。</li>
<li>如果值中不可避免的使用；，=以及空格，则需要用escape函数进行编码，读取时用unescape来解码</li>
<li>可设置有效时间，用expires字段保存，所以若要删除一个cookie将其expires字段设置为一个过去的时间即可，若不设定过期时间，即当浏览器关闭时cookie自动消失。</li>
<li>指定可访问cookie的主机名：<ul>
<li>例如www.google.com和gmail.google.com就是同一域google.com下的两个不同主机名</li>
<li>而不同主机的cookie不能相互访问</li>
<li>但可以通过domain参数来实现对其的控制</li>
<li>document.cookie = “name=value;domain=.google.com”，这样所有google.com下的主机都可以访问该cookie</li>
</ul>
</li>
<li>是服务器写入浏览器的一小段信息，只有同源的网页才能共享</li>
<li><p>为了规避这种限制，又引入了一种机制，当两个网页一级域名相同，只是二级域名不同时，浏览器允许通过document.domain共享cookie</p>
<h6 id="举例说明：-1"><a href="#举例说明：-1" class="headerlink" title="举例说明："></a>举例说明：</h6><p>A网页时<code>http://w1.example.com/a.html</code>，B网页时<code>http://w2.example.com/b.html</code>,设置document.domain = “example.com”</p>
</li>
<li><p>在A网页中通过脚本设置一个cookie，document.cookie = “test=hello”;</p>
</li>
<li>B网页中就可以读取，var allcookies = document.cookie</li>
<li><p>或者直接通过服务器设置cookie，指定cookie所属的域名为一级域名，则二级域名和三级域名不用设置即可读取这个歌cookie</p>
<pre><code>Set-Cookie: key=value;domain=.example.com;path=/
</code></pre></li>
</ul>
<p>但是此种共享只适用于cookie和iframe窗口，localStorage和indexDB无法通过这种方法</p>
<h3 id="iframe实现跨域的三种方式"><a href="#iframe实现跨域的三种方式" class="headerlink" title="iframe实现跨域的三种方式"></a>iframe实现跨域的三种方式</h3><p>iframe窗口和父窗口不是同源的话，不能取得对方的DOM。</p>
<p>即：</p>
<pre><code>//父窗口执行
document.getElementById(&quot;myIFrame&quot;).contentWindow.document
//自窗口执行
window.parent.document.body
</code></pre><p>以上两种形式均会报错</p>
<p>解决方式：</p>
<ul>
<li>若两个窗口一级域名相同，只是二级域名不同，那么通过document.domain属性，就可以规避同源政策，拿到DOM</li>
<li>若两个完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。<ul>
<li>片段识别符（fragment identifier）</li>
<li>window.name</li>
<li>跨文档通信API(Cross-document messaging)</li>
</ul>
</li>
</ul>
<h4 id="一、片段标识符"><a href="#一、片段标识符" class="headerlink" title="一、片段标识符"></a>一、片段标识符</h4><p>指的是网页URL<code>#</code>后面的部分，比如<code>http://example.com/x.html#fragment</code>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</p>
<p>父窗口将信息写入子窗口的片段标识符中</p>
<pre><code>var iframe = document.getElementById(&quot;myIFrame&quot;);
var src = iframe.src  + &quot;#&quot; + sharedata;
iframe.src = src;
</code></pre><p>子窗口就可以通过监听hashchange事件得到通知。</p>
<pre><code>window.onhashchange = checkmessage;

function checkmessage (){
    var message = window.location.hash;
}
</code></pre><p>子窗口也可改变父窗口的片段标识符</p>
<pre><code>parent.location.href = target + &quot;#&quot; + hash;
</code></pre><h4 id="二、window-name"><a href="#二、window-name" class="headerlink" title="二、window.name"></a>二、window.name</h4><p>window的name属性无论同源与否，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页就可以读取它。</p>
<p>父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性中</p>
<pre><code>window.name = sharedata;
</code></pre><p>子窗口跳回一个与父窗口同域的网址</p>
<pre><code>location = &quot;http://parent.com/xxx.html&quot;;
</code></pre><p>此时主窗口就可以读取子窗口的window.name了。</p>
<pre><code>var getdata = document.getElementById(&apos;myFrame&apos;).contentWindow.name;
</code></pre><p>由于window.name容量很大，可以放置非常长的字符串，但是</p>
<p>缺点是：父窗口必须监听子窗口的window.name的变化，会影响页面的性能。</p>
<h4 id="三、window-postMessage"><a href="#三、window-postMessage" class="headerlink" title="三、window.postMessage"></a>三、window.postMessage</h4><p>HTML5引入了一个全新的API：跨文档通信API，叫作Cross-document messaging。这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，无论同源与否。</p>
<p>举例来说：</p>
<p>父窗口嵌入子窗口：</p>
<pre><code>&lt;iframe src = &quot;http://bbb.com:8080/otherpage.html&quot; id = &quot;otherpage&quot;&gt;&lt;/iframe&gt;
</code></pre><p>父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用postMessage方法就可以</p>
<pre><code>var popup = document.getElementById(&apos;otherpage&apos;).contentWindow;
popup.postMessage(&apos;hello world&apos;,&apos;http://bbb.com&apos;);
</code></pre><p>postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源，即 协议+域名+端口，也可设置为*，表示不限制域名，向所有窗口发送。</p>
<p>子窗口向父窗口发送消息的写法类似。</p>
<pre><code>window.opener.postMessage(&quot;Nice to see you&quot;,&quot;http://aaa.com&quot;);
</code></pre><p>父子窗口都可以通过message事件，监听对方的消息。</p>
<pre><code>window.addEventListener(&apos;message&apos;,function(e){
    console.log(e.data);
    //这里需要回复消息的话，可以直接用event.source来回复
    event.source.postMessage(&apos;message have recevied&apos;,&quot;*&quot;);
})
</code></pre><p>message事件的事件对象event，提供一下三个属性</p>
<ul>
<li>event.source：发送消息的窗口//可直接回复消息</li>
<li>event.origin：消息发向的网址//过滤不是给本窗口发送的消息，比如有些不限制域名向所有窗口发送的消息，如果接收则会浪费资源</li>
<li>event.data：接收到的消息内容</li>
</ul>
<p>event.origin属性的用法：</p>
<pre><code>window.addEventListener(&apos;message&apos;,recevieMessage);
function recevieMessage(event){
    if(event.origin !== &apos;http://aaa.com&apos;) return;
    ...
}
</code></pre><h4 id="四、LocalStorage"><a href="#四、LocalStorage" class="headerlink" title="四、LocalStorage"></a>四、LocalStorage</h4><p>通过window.postMessage，可相互读写localStorage</p>
<h3 id="跨域AJAX请求不能发送规避方式"><a href="#跨域AJAX请求不能发送规避方式" class="headerlink" title="跨域AJAX请求不能发送规避方式"></a>跨域AJAX请求不能发送规避方式</h3><p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错。</p>
<p>除了服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
<h4 id="一、JSONP-JSON-with-padding"><a href="#一、JSONP-JSON-with-padding" class="headerlink" title="一、JSONP (JSON with padding)"></a>一、JSONP (JSON with padding)</h4><p>JSONP是服务器与客户端跨源通信的常用方法。因为同源策略不阻止动态脚本插入，动态插入的脚本会被当做是当前域上加载的。</p>
<pre><code>function addScriptTag(src) {
  var script = document.createElement(&apos;script&apos;);
  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);
  script.src = src;
  document.body.appendChild(script);
}

window.onload = function () {
  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);
}

function foo(data) {
  console.log(&apos;Your public IP address is: &apos; + data.ip);
};
</code></pre><p>服务器example.com收到请求后，会将请求的ip值放在指定的callback回调函数foo中放回，如下：</p>
<pre><code>foo({
    &quot;ip&quot; : &quot;8.8.8.8&quot;
})
</code></pre><p>§<br>而由于<code>&lt;script&gt;</code>元素请求的脚本会直接作为代码运行。这时，所以返回的这段代码将会直接运行。</p>
<h4 id="二、websocket"><a href="#二、websocket" class="headerlink" title="二、websocket"></a>二、websocket</h4><p>websocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源策略，只要服务器支持就可以跨域通信。</p>
<p>websocket请求的头信息：</p>
<pre><code>GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
</code></pre><p>请求头信息有个origin，就是该请求的请求源，即该请求发自哪个域名，服务器可以通过这个字段来判断时候允许这次通信，若是该域在白名单中，服务器就会响应</p>
<pre><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</code></pre><h4 id="三、CORS"><a href="#三、CORS" class="headerlink" title="三、CORS"></a>三、CORS</h4><p>CORS是w3c标准，全称是“跨域资源共享”（Cross-origin resource sharing）。</p>
<p>待补充。。。。</p>
<h3 id="跨域的使用场景"><a href="#跨域的使用场景" class="headerlink" title="跨域的使用场景"></a>跨域的使用场景</h3><h4 id="一、前端跨域方式："><a href="#一、前端跨域方式：" class="headerlink" title="一、前端跨域方式："></a>一、前端跨域方式：</h4><ul>
<li>image.src、style.href无法获取服务器的数据返回，适合发送数据但不需要得到返回数据，比如向服务器发送错误信息</li>
<li>script.src和服务器端配合可以得到数据返回</li>
<li>postMessage，window.name，document.domain是两个窗口相互传递<ul>
<li>postMessage需要IE8+,firefox,chrome,safari,opera支持</li>
<li>window.name限制大小2M，但所有浏览器支持</li>
<li>document.domain必须跨域双方的顶级域名相同</li>
</ul>
</li>
</ul>
<h4 id="二、前后端结合"><a href="#二、前后端结合" class="headerlink" title="二、前后端结合"></a>二、前后端结合</h4><p>jsonp</p>
<h4 id="三、纯后端"><a href="#三、纯后端" class="headerlink" title="三、纯后端"></a>三、纯后端</h4><ul>
<li>CORS：是w3c标准的方式，通过web服务器端设置，响应Access-Control-Alow-Origin来指定白名单</li>
<li>服务器代理，通过服务器转发请求</li>
</ul>
<h2 id="JavaScript闭包"><a href="#JavaScript闭包" class="headerlink" title="JavaScript闭包"></a>JavaScript闭包</h2><h4 id="一、变量的作用域"><a href="#一、变量的作用域" class="headerlink" title="一、变量的作用域"></a>一、变量的作用域</h4><p>要理解闭包，首先要理解JavaScript的作用域：全局和局部。</p>
<p>函数内部可以读取全局变量，但是函数外部无法读取函数内部的局部作用域。</p>
<h4 id="二、从外部读取局部变量"><a href="#二、从外部读取局部变量" class="headerlink" title="二、从外部读取局部变量"></a>二、从外部读取局部变量</h4><p>将内部函数作为返回值，就可以在outter函数外部读取其内部变量值了</p>
<pre><code>function outter (){
    var n = 999;
    function inner (){
        alert(n);
    }
    return n;
}

var result = outter();
result();//999
</code></pre><h4 id="三、闭包的概念"><a href="#三、闭包的概念" class="headerlink" title="三、闭包的概念"></a>三、闭包的概念</h4><p>我理解为：闭包就是能够读取其他函数内部变量的函数，但是本质上，闭包就是连接函数内部和外部的一座桥梁</p>
<h4 id="四、闭包的用途"><a href="#四、闭包的用途" class="headerlink" title="四、闭包的用途"></a>四、闭包的用途</h4><ul>
<li>可以读取函数内部的变量</li>
<li><p>让这些变量值始终保存在内存中</p>
<pre><code>function f1(){
  　　　　var n=999;
  　　　　nAdd=function(){n+=1}
  　　　　function f2(){
  　　　　　　alert(n);
  　　　　}
  　　　　return f2;
  　　}
  　　var result=f1();
  　　result(); // 999
  　　nAdd();
  　　result(); // 1000
</code></pre></li>
</ul>
<p>说明函数f1中的局部变量n一直保存在内存中，并没有在f1调用后自动清除，因为内部函数f2被赋值给了一个全局变量，导致f2一直在内存中，而f2存在依赖于f1，所以f1也始终在内存中，而不是在调用结束后没被来及回收机制回收。</p>
<p>五、闭包的注意事项</p>
<ul>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，解决方法是，在退出函数之前，将不适用的局部变量全部删除。</li>
<li>闭包在父函数外部可以改变父函数内部变量的值，不要随便改变父函数内部变量的值</li>
</ul>
<h2 id="JavaScript数组去重"><a href="#JavaScript数组去重" class="headerlink" title="JavaScript数组去重"></a>JavaScript数组去重</h2><pre><code>Array.prototype.unique1 = function()
{
    var n = []; //一个新的临时数组
    for(var i = 0; i &lt; this.length; i++) //遍历当前数组
    {
        //如果当前数组的第i已经保存进了临时数组，那么跳过，
        //否则把当前项push到临时数组里面
        if (n.indexOf(this[i]) == -1) n.push(this[i]);
    }
    return n;
}
</code></pre><p>### </p>
<pre><code>Array.prototype.unique3 = function()
{
    var n = [this[0]]; //结果数组
    for(var i = 1; i &lt; this.length; i++) //从第二项开始遍历
    {
        //如果当前数组的第i项在当前数组中第一次出现的位置不是i，
        //那么表示第i项是重复的，忽略掉。否则存入结果数组
        if (this.indexOf(this[i]) == i) n.push(this[i]);
    }
    return n;
}
</code></pre><p>### </p>
<pre><code>Array.prototype.unique4 = function()
{
    this.sort();
    var re=[this[0]];
    for(var i = 1; i &lt; this.length; i++)
    {
        if( this[i] !== re[re.length-1])
        {
            re.push(this[i]);
        }
    }
    return re;
}
</code></pre><h2 id="JavaScript参数传递"><a href="#JavaScript参数传递" class="headerlink" title="JavaScript参数传递"></a>JavaScript参数传递</h2><p>JavaScript中的参数传递和其他的计算机语言有所不同，定义的函数只接收两个参数，你也可以传递一个或者三个甚至不传参数，原因是：</p>
<ul>
<li>因为在ECMAScript中参数在内部是用一个数组来表示的，函数接收到的始终是这个数组，并不关心这个数组内部是否有元素</li>
<li>也可以直接使用arguments对象来访问参数</li>
</ul>
<h3 id="传递参数的方式"><a href="#传递参数的方式" class="headerlink" title="传递参数的方式"></a>传递参数的方式</h3><p>JavaScript中所有的函数的参数都是按值传递的</p>
<ul>
<li><p>基本类型</p>
<pre><code>function addTen(num){
    num += 10;
    return num;
}
var count = 20;
var result = addTen(count); //count被传入函数时，只是将count的值赋给num这个局部变量，
alert(count); //20
alert(result); //30
</code></pre></li>
<li>引用类型</li>
</ul>
<p>有很多人会在引用类型当做参数被传递时感到疑惑，例如：</p>
<pre><code>function setName(obj){
    obj.name = &quot;localname&quot;;
}
var person = new Object();
setName(person);
alert(person.name); //localname
</code></pre><p>在函数内部改变obj的name反映到了全局作用域中的对象person中了，看起来像是参数按照引用传递的，接下来看下面的代码：</p>
<pre><code>function setName(obj){
    obj.name = &quot;localname&quot;;
    obj = new Object();
    obj.name = &quot;changename&quot;;
}
var person = new Object();
setName(person);
alert(person.name); //localname
</code></pre><p>假设是按引用传递的参数，那person的name应该是changename才对</p>
<p>事实上：</p>
<ul>
<li>当person当做参数传递给setName函数时，setName作用域内的局部变量obj对象会指向person对象</li>
<li>第一次obj.name被赋值localname时，实际上是person对象的name属性被赋值为localname，当obj指向一个新对象后，和person再就没有关系了</li>
<li>所以当第二次obj.name被赋值changename时，person不会受到任何影响</li>
</ul>
<h2 id="JavaScript中错误类型"><a href="#JavaScript中错误类型" class="headerlink" title="JavaScript中错误类型"></a>JavaScript中错误类型</h2><h3 id="SyntaxError（语法错误）"><a href="#SyntaxError（语法错误）" class="headerlink" title="SyntaxError（语法错误）"></a>SyntaxError（语法错误）</h3><p>解析代码时发生的语法错误</p>
<pre><code>eg:var 1a;
Uncaught SyntaxError: Unexpected number
</code></pre><h3 id="ReferenceError（引用错误）"><a href="#ReferenceError（引用错误）" class="headerlink" title="ReferenceError（引用错误）"></a>ReferenceError（引用错误）</h3><p>a.引用了一个不存在的变量</p>
<pre><code>eg:console.log(a);
Uncaught ReferenceError: a is not defined
</code></pre><p>b.将变量赋值给一个无法被赋值的对象</p>
<pre><code>eg:console.log()=1;
Uncaught ReferenceError:Invalid left-hand side in assignment
</code></pre><h3 id="RangeError-范围错误"><a href="#RangeError-范围错误" class="headerlink" title="RangeError(范围错误)"></a>RangeError(范围错误)</h3><p>超出有效范围</p>
<h3 id="TypeError（类型错误）"><a href="#TypeError（类型错误）" class="headerlink" title="TypeError（类型错误）"></a>TypeError（类型错误）</h3><p>a.变量或参数不是预期类型，比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数</p>
<pre><code>eg: var a= new 123;
Uncaught TypeError: 123 is not a function
</code></pre><p>b.调用对象不存在的方法</p>
<pre><code>eg:var a;a.aa();
Uncaught TypeError: Cannot read property &apos;aa&apos; of undefined
</code></pre><h3 id="URLError（URL错误）"><a href="#URLError（URL错误）" class="headerlink" title="URLError（URL错误）"></a>URLError（URL错误）</h3><h3 id="EvalError（eval错误）"><a href="#EvalError（eval错误）" class="headerlink" title="EvalError（eval错误）"></a>EvalError（eval错误）</h3><p>eval函数没有被正确执行</p>
<h2 id="JavaScript的异常捕获机制"><a href="#JavaScript的异常捕获机制" class="headerlink" title="JavaScript的异常捕获机制"></a>JavaScript的异常捕获机制</h2><h3 id="基本的try…catch语句"><a href="#基本的try…catch语句" class="headerlink" title="基本的try…catch语句"></a>基本的try…catch语句</h3><p>语法如下：</p>
<pre><code>try{
    //可能发生异常的代码
}catch(error){
    //发生错误执行的代码
}
</code></pre><p>实例：</p>
<pre><code>try{
    console.log(b);
    console.log(&quot;我不会输出的，不要找了&quot;)

}catch(error){
    console.log(&quot;发生错误了&quot;)
}
console.log(&quot;我try catch后面的代码&quot;)
</code></pre><ul>
<li>把有可能出问题的代码放在try语句中，try语句中理论上可以写任何代码，只要有一行代码出现问题，整个程序的执行流程就会立即调到catch语句中执行。</li>
<li>一旦try中有一行代码发生异常，则这行出错代码的后面的try中的其他语句都不会再执行。比如上面代码中的console.log(b);这行代码会出错，则立即去执行catch中的代码。所以console.log(“我不会输出的，不要找了”)这行代码则不会再执行</li>
<li>在执行catch中的代码之前，js引擎会首先根据错误类型自动创建一个错误，并通过catch后面的参数传递到catch中。不同的浏览器创建的error对象不一样，但是同创他们都包含一个message属性，值是这个错误的一些信息。</li>
<li>catch中的代码执行完毕之后，会继续执行后面的代码，程序不会停止下来。</li>
</ul>
<h3 id="根据不同错误类型分别处理"><a href="#根据不同错误类型分别处理" class="headerlink" title="根据不同错误类型分别处理"></a>根据不同错误类型分别处理</h3><pre><code>try { 
  someFunction(); 
} catch (error){ 
  if (error instanceof TypeError){ 
    //处理ૌ类型错误 
  } else if (error instanceof ReferenceError){ 
    //处理引用错误 
  } else { 
      //处理其他的错误 
  }
}
</code></pre><ul>
<li>Error类型是基本的错误类型，其他类型都继承自这个类型。</li>
<li>EvalError 类型的错误会在使用 eval()函数而发生异常时被抛出</li>
<li>TypeError 类型在 JavaScript 中会经常用到，在变量中保存着意外的类型时，或者在访问不存在的 方法时，都会导致这种错误</li>
<li>一般情况，不同的错误，处理方式不一样。可以参考下面的处理方式。不过在实际开发中，很多程序员并没有形成处理错误的习惯。</li>
</ul>
<h3 id="throw主动抛出异常"><a href="#throw主动抛出异常" class="headerlink" title="throw主动抛出异常"></a>throw主动抛出异常</h3><h4 id="抛出JavaScript内置错误类型的对象"><a href="#抛出JavaScript内置错误类型的对象" class="headerlink" title="抛出JavaScript内置错误类型的对象"></a>抛出JavaScript内置错误类型的对象</h4><pre><code>function foo(num) {
    if(typeof num == &quot;number&quot;){
        return num * num;
    }else{
        throw new TypeError(&quot;类型错误，你应该传入一个数字...&quot;)
    }
}
console.log(foo(33))
console.log(foo(&quot;abc&quot;))
</code></pre><ul>
<li>throw后面就是我们要抛出的异常对象。在以前的时候都是出现错误的时候浏览器抛出异常对象，只是现在是我们自己主动抛出的异常对象。</li>
<li>只要有异常对象抛出，不管是浏览器抛出的，还是代码主动抛出，都会让程序停止执行。如果想让程序继续执行，则有也可以用try…catch来捕获。</li>
<li>每一个错误类型都可以传入一个参数，表示实际的错误信息。</li>
<li>我们可以在适当的时候抛出任何我们想抛出的异常类型。throw new SyntaxError(“语法错误…”);</li>
</ul>
<h4 id="抛出自定义类型的错误对象"><a href="#抛出自定义类型的错误对象" class="headerlink" title="抛出自定义类型的错误对象"></a>抛出自定义类型的错误对象</h4><p>我们不仅仅可以抛出js内置的错误类型的对象，也可以自定义错误类型，然后抛出自定义错误类型的对象。</p>
<p>​如果要自定义错误类型，只需要继承任何一个自定义错误类型都可以。一般直接继承Error即可。</p>
<pre><code>function MyError(message) {
    this.message = &quot;注意：这是自定义的错误&quot;
    this.name = &quot;自定义错误&quot;;
}
MyError.prototype = new Error();
try {
    throw new MyError(&quot;注意：这是自定义错误类型&quot;)
}catch (error){
    console.log(error.message)
}
console.log(&quot;这里会不会执行&quot;)
</code></pre><h2 id="关于前端网络部分知识"><a href="#关于前端网络部分知识" class="headerlink" title="关于前端网络部分知识"></a>关于前端网络部分知识</h2><h3 id="http协议相关问题"><a href="#http协议相关问题" class="headerlink" title="http协议相关问题"></a>http协议相关问题</h3><h4 id="常见的http状态码"><a href="#常见的http状态码" class="headerlink" title="常见的http状态码"></a>常见的http状态码</h4><h5 id="1字头-消息"><a href="#1字头-消息" class="headerlink" title="1字头-消息"></a>1字头-消息</h5><p>这类型状态码代表请求已被接受，需要继续处理。</p>
<ul>
<li>100 continue 客户端应当继续发送请求</li>
<li>101 switching protocols </li>
<li>102 </li>
</ul>
<h5 id="2字头-消息"><a href="#2字头-消息" class="headerlink" title="2字头-消息"></a>2字头-消息</h5><p>这类型状态码代表请求已成功被服务器接收、理解、并接受</p>
<ul>
<li>200 OK 请求已成功</li>
<li>201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立</li>
<li>202 Accepted 服务器已接受请求，但尚未处理</li>
<li>203 Non-Authoritative Information <h4 id="http请求头"><a href="#http请求头" class="headerlink" title="http请求头"></a>http请求头</h4></li>
<li><h4 id="http响应头"><a href="#http响应头" class="headerlink" title="http响应头"></a>http响应头</h4></li>
</ul>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2017/04/13/JavaScript典型问题总结（二）/" data-toggle="tooltip" data-placement="top"
                           title="JavaScript典型问题总结（二）">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2017/04/13/chrome书签/" data-toggle="tooltip" data-placement="top"
                           title="chrome书签">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript数据类型"><span class="toc-text">JavaScript数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript检测类型"><span class="toc-text">JavaScript检测类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript基本数据类型"><span class="toc-text">JavaScript基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript复杂数据类型（引用类型）"><span class="toc-text">JavaScript复杂数据类型（引用类型）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript中运算符优先级"><span class="toc-text">JavaScript中运算符优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript事件委托"><span class="toc-text">JavaScript事件委托</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用实例："><span class="toc-text">使用实例：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#jQuery中"><span class="toc-text">jQuery中</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript事件流"><span class="toc-text">JavaScript事件流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#事件冒泡：IE的事件流叫作事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较不具体的节点（document对象）"><span class="toc-text">事件冒泡：IE的事件流叫作事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较不具体的节点（document对象）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#事件捕获：Netscape提出另一种事件流叫做事件捕获，即事件熊不太具体的节点（document对象）沿着DOM树依次向下，一直传播到事件的实际目标（具体的节点）"><span class="toc-text">事件捕获：Netscape提出另一种事件流叫做事件捕获，即事件熊不太具体的节点（document对象）沿着DOM树依次向下，一直传播到事件的实际目标（具体的节点）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DOM事件流：包括事件捕获阶段，处于目标阶段，和事件冒泡阶段"><span class="toc-text">DOM事件流：包括事件捕获阶段，处于目标阶段，和事件冒泡阶段</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript中Global对象，window对象，document对象的区别"><span class="toc-text">JavaScript中Global对象，window对象，document对象的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript中的this"><span class="toc-text">JavaScript中的this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#情况一：纯粹的函数调用"><span class="toc-text">情况一：纯粹的函数调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#情况二：作为对象方法的调用"><span class="toc-text">情况二：作为对象方法的调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#情况三：作为构造函数调用"><span class="toc-text">情况三：作为构造函数调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#情况四：apply调用"><span class="toc-text">情况四：apply调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript中的new"><span class="toc-text">JavaScript中的new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript继承机制的设计思想"><span class="toc-text">JavaScript继承机制的设计思想</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#所以引入了原型prototype："><span class="toc-text">所以引入了原型prototype：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript创建对象"><span class="toc-text">JavaScript创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript的继承实现"><span class="toc-text">JavaScript的继承实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript对对象的封装"><span class="toc-text">JavaScript对对象的封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、最原始的生成对象模式"><span class="toc-text">一、最原始的生成对象模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、原始模式改进"><span class="toc-text">二、原始模式改进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、构造函数模式"><span class="toc-text">三、构造函数模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四、prototype模式"><span class="toc-text">四、prototype模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript中构造函数的继承"><span class="toc-text">JavaScript中构造函数的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、构造函数绑定"><span class="toc-text">一、构造函数绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、prototype模式"><span class="toc-text">二、prototype模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、直接继承prototype"><span class="toc-text">三、直接继承prototype</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript实现浅拷贝和深拷贝"><span class="toc-text">JavaScript实现浅拷贝和深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XMLHttpRequest对象深入理解"><span class="toc-text">XMLHttpRequest对象深入理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原生JavaScript实现ajax请求"><span class="toc-text">原生JavaScript实现ajax请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跨域的实现方式"><span class="toc-text">跨域的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#域名"><span class="toc-text">域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同源策略"><span class="toc-text">同源策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引入同源策略的目的：为了保证用户的信息安全，防止恶意的网站窃取数据"><span class="toc-text">引入同源策略的目的：为了保证用户的信息安全，防止恶意的网站窃取数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#所谓同源指的是"><span class="toc-text">所谓同源指的是</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#举例说明："><span class="toc-text">举例说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#目前非同源时，共有三种行为受到限制"><span class="toc-text">目前非同源时，共有三种行为受到限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie跨域规避方式"><span class="toc-text">cookie跨域规避方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#举例说明：-1"><span class="toc-text">举例说明：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iframe实现跨域的三种方式"><span class="toc-text">iframe实现跨域的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、片段标识符"><span class="toc-text">一、片段标识符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、window-name"><span class="toc-text">二、window.name</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、window-postMessage"><span class="toc-text">三、window.postMessage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四、LocalStorage"><span class="toc-text">四、LocalStorage</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跨域AJAX请求不能发送规避方式"><span class="toc-text">跨域AJAX请求不能发送规避方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、JSONP-JSON-with-padding"><span class="toc-text">一、JSONP (JSON with padding)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、websocket"><span class="toc-text">二、websocket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、CORS"><span class="toc-text">三、CORS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跨域的使用场景"><span class="toc-text">跨域的使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、前端跨域方式："><span class="toc-text">一、前端跨域方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、前后端结合"><span class="toc-text">二、前后端结合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、纯后端"><span class="toc-text">三、纯后端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript闭包"><span class="toc-text">JavaScript闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、变量的作用域"><span class="toc-text">一、变量的作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、从外部读取局部变量"><span class="toc-text">二、从外部读取局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、闭包的概念"><span class="toc-text">三、闭包的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四、闭包的用途"><span class="toc-text">四、闭包的用途</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript数组去重"><span class="toc-text">JavaScript数组去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript参数传递"><span class="toc-text">JavaScript参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#传递参数的方式"><span class="toc-text">传递参数的方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript中错误类型"><span class="toc-text">JavaScript中错误类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SyntaxError（语法错误）"><span class="toc-text">SyntaxError（语法错误）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReferenceError（引用错误）"><span class="toc-text">ReferenceError（引用错误）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RangeError-范围错误"><span class="toc-text">RangeError(范围错误)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeError（类型错误）"><span class="toc-text">TypeError（类型错误）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URLError（URL错误）"><span class="toc-text">URLError（URL错误）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EvalError（eval错误）"><span class="toc-text">EvalError（eval错误）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript的异常捕获机制"><span class="toc-text">JavaScript的异常捕获机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本的try…catch语句"><span class="toc-text">基本的try…catch语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#根据不同错误类型分别处理"><span class="toc-text">根据不同错误类型分别处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw主动抛出异常"><span class="toc-text">throw主动抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#抛出JavaScript内置错误类型的对象"><span class="toc-text">抛出JavaScript内置错误类型的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#抛出自定义类型的错误对象"><span class="toc-text">抛出自定义类型的错误对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于前端网络部分知识"><span class="toc-text">关于前端网络部分知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http协议相关问题"><span class="toc-text">http协议相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常见的http状态码"><span class="toc-text">常见的http状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1字头-消息"><span class="toc-text">1字头-消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2字头-消息"><span class="toc-text">2字头-消息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http请求头"><span class="toc-text">http请求头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http响应头"><span class="toc-text">http响应头</span></a></li></ol></li></ol></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#JavaScript"
                           title="JavaScript">JavaScript</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <div style="margin-top: 20px;">
                    <h5 class="text-center">FRIENDS</h5>
                    <ul class="list-inline text-center">
                        
                        <li><a href="https://aiyuzhou.github.io/">Annie&#39; blog</a></li>
                        
                        <li><a href="https://aiyuzhou.github.io/">haha</a></li>
                        
                    </ul>
                </div>
                
            </div>
        </div>

    </div>
</article>






<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/ben-xiao-niu">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/喵喵小妞52221">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/aiyuzhou">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Annie 2018
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://aiyuzhou.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','null','2.0.0');
</script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="http://oi7koh9y1.bkt.clouddn.com/headImg.jpg">
</body>

</html>
